<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hen-Tersection â€” Intelligent Crosswalk System</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Syne:wght@700;800&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0d0f14;
  --surface: #13161e;
  --surface2: #1a1e28;
  --border: rgba(255,255,255,0.07);
  --accent: #f5a623;
  --accent2: #e8572a;
  --go: #22c55e;
  --stop: #ef4444;
  --warn: #f59e0b;
  --blue: #3b82f6;
  --text: #e8eaf0;
  --muted: rgba(232,234,240,0.45);
  --font-display: 'Syne', sans-serif;
  --font-body: 'DM Sans', sans-serif;
  --font-mono: 'DM Mono', monospace;
}

* { margin:0; padding:0; box-sizing:border-box; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--font-body);
  font-size: 14px;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

/* â”€â”€ NAV â”€â”€ */
nav {
  display: flex;
  align-items: center;
  gap: 0;
  padding: 0 0 0 24px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  height: 52px;
  flex-shrink: 0;
  z-index: 100;
}

.nav-logo {
  font-family: var(--font-display);
  font-size: 1.1rem;
  font-weight: 800;
  letter-spacing: -0.02em;
  margin-right: 32px;
  color: var(--text);
}
.nav-logo span { color: var(--accent); }

.nav-tab {
  height: 52px;
  padding: 0 18px;
  display: flex;
  align-items: center;
  gap: 7px;
  font-size: 0.78rem;
  font-weight: 500;
  color: var(--muted);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.18s;
  white-space: nowrap;
  letter-spacing: 0.01em;
}
.nav-tab:hover { color: var(--text); }
.nav-tab.active { color: var(--text); border-bottom-color: var(--accent); }
.nav-tab .dot { width:6px; height:6px; border-radius:50%; background:currentColor; }
.nav-tab.live .dot { background: var(--go); box-shadow: 0 0 6px var(--go); animation: pulse 1.5s infinite; }
@keyframes pulse { 0%,100%{opacity:1}50%{opacity:0.4} }

.nav-right { margin-left: auto; display:flex; align-items:center; gap:12px; padding-right:20px; }

.badge {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  padding: 3px 8px;
  border-radius: 3px;
  background: var(--surface2);
  border: 1px solid var(--border);
  color: var(--muted);
}
.badge.green { border-color: rgba(34,197,94,0.3); color: var(--go); }

/* â”€â”€ PAGES â”€â”€ */
.page { display:none; flex:1; overflow:hidden; }
.page.active { display:flex; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PAGE 1 â€” LIVE MONITOR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#page-live {
  flex-direction: row;
  gap: 0;
}

.live-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
}

.camera-container {
  flex: 1;
  position: relative;
  background: #000;
  overflow: hidden;
  min-height: 0;
}

#video {
  width: 100%; height: 100%;
  object-fit: cover;
  display: block;
  transform: scaleX(-1);
}

#canvas {
  position: absolute; inset:0;
  width: 100%; height: 100%;
  transform: scaleX(-1);
  pointer-events: none;
}

.cam-overlay {
  position: absolute; inset: 0;
  pointer-events: none;
}

.cam-corner {
  position: absolute;
  width: 24px; height: 24px;
}
.cam-corner.tl { top:12px; left:12px; border-top: 2px solid var(--accent); border-left: 2px solid var(--accent); }
.cam-corner.tr { top:12px; right:12px; border-top: 2px solid var(--accent); border-right: 2px solid var(--accent); }
.cam-corner.bl { bottom:12px; left:12px; border-bottom: 2px solid var(--accent); border-left: 2px solid var(--accent); }
.cam-corner.br { bottom:12px; right:12px; border-bottom: 2px solid var(--accent); border-right: 2px solid var(--accent); }

.cam-info {
  position: absolute;
  top: 16px; left: 50%;
  transform: translateX(-50%);
  font-family: var(--font-mono);
  font-size: 0.65rem;
  color: rgba(255,255,255,0.5);
  letter-spacing: 0.1em;
  text-transform: uppercase;
}

.cam-fps {
  position: absolute;
  top: 12px; right: 52px;
  font-family: var(--font-mono);
  font-size: 0.62rem;
  color: rgba(255,255,255,0.4);
}

.cam-rec {
  position: absolute;
  top: 14px; left: 14px;
  display: flex;
  align-items: center;
  gap: 5px;
  font-family: var(--font-mono);
  font-size: 0.6rem;
  color: var(--stop);
  letter-spacing: 0.1em;
}
.rec-dot { width:6px; height:6px; border-radius:50%; background:var(--stop); animation: pulse 1s infinite; }

/* Traffic light signal display */
.signal-overlay {
  position: absolute;
  bottom: 16px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: flex-end;
  gap: 20px;
  pointer-events: none;
}

.traffic-light {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  background: rgba(0,0,0,0.85);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 8px;
  padding: 8px 10px;
}
.light-label { font-family: var(--font-mono); font-size: 0.55rem; color: rgba(255,255,255,0.4); letter-spacing:0.1em; text-transform:uppercase; }
.lights { display: flex; flex-direction: column; gap: 5px; }
.light-bulb { width: 20px; height: 20px; border-radius: 50%; background: rgba(255,255,255,0.08); transition: all 0.3s; }
.light-bulb.red.on { background: #ef4444; box-shadow: 0 0 12px #ef4444; }
.light-bulb.yellow.on { background: #f59e0b; box-shadow: 0 0 12px #f59e0b; }
.light-bulb.green.on { background: #22c55e; box-shadow: 0 0 12px #22c55e; }

.walk-signal {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  background: rgba(0,0,0,0.85);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 8px;
  padding: 8px 14px;
}
.walk-icon {
  font-size: 2rem;
  transition: all 0.3s;
  filter: grayscale(1) opacity(0.3);
}
.walk-icon.walk { filter: none; animation: walkAnim 0.5s ease-in-out infinite alternate; }
.walk-icon.dont-walk { filter: none; color: var(--stop); animation: none; }
@keyframes walkAnim { from{transform:translateY(0)} to{transform:translateY(-2px)} }

.countdown-ring {
  width: 48px; height: 48px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}
.countdown-ring svg { position: absolute; inset:0; transform: rotate(-90deg); }
.countdown-ring .ring-track { fill:none; stroke: rgba(255,255,255,0.1); stroke-width: 3; }
.countdown-ring .ring-fill { fill:none; stroke-width: 3; stroke-linecap: round; transition: stroke-dashoffset 1s linear, stroke 0.3s; }
.countdown-num {
  font-family: var(--font-mono);
  font-size: 1.1rem;
  font-weight: 500;
  color: var(--text);
  z-index: 1;
}

/* Bottom bar */
.cam-bottom-bar {
  height: 48px;
  background: var(--surface);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 16px;
  gap: 12px;
  flex-shrink: 0;
}

.voice-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.75rem;
  color: var(--muted);
  flex: 1;
}
.voice-bars { display: flex; align-items: flex-end; gap: 2px; height: 16px; }
.voice-bar {
  width: 3px;
  background: var(--accent);
  border-radius: 1.5px;
  transition: height 0.15s;
  opacity: 0.4;
}
.voice-bar.active { opacity: 1; animation: voiceAnim 0.3s ease-in-out infinite alternate; }
.voice-bar:nth-child(1) { animation-delay: 0s; }
.voice-bar:nth-child(2) { animation-delay: 0.1s; }
.voice-bar:nth-child(3) { animation-delay: 0.05s; }
.voice-bar:nth-child(4) { animation-delay: 0.15s; }
@keyframes voiceAnim { from{height:4px}to{height:14px} }

.btn {
  padding: 7px 16px;
  border-radius: 6px;
  border: 1px solid var(--border);
  background: var(--surface2);
  color: var(--text);
  font-family: var(--font-body);
  font-size: 0.75rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.18s;
  white-space: nowrap;
}
.btn:hover { border-color: rgba(255,255,255,0.15); background: rgba(255,255,255,0.05); }
.btn.primary { background: var(--accent); border-color: var(--accent); color: #000; font-weight: 600; }
.btn.primary:hover { filter: brightness(1.1); }
.btn.danger { border-color: rgba(239,68,68,0.4); color: var(--stop); }

/* Right panel */
.live-sidebar {
  width: 300px;
  background: var(--surface);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.sidebar-section {
  border-bottom: 1px solid var(--border);
  padding: 14px 16px;
}

.sidebar-section:last-child { border-bottom: none; flex: 1; overflow: hidden; display:flex; flex-direction:column; }

.section-label {
  font-size: 0.65rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--muted);
  margin-bottom: 10px;
}

/* Stats grid */
.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.stat-card {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px 12px;
}
.stat-card-val {
  font-family: var(--font-mono);
  font-size: 1.4rem;
  font-weight: 500;
  line-height: 1;
  margin-bottom: 4px;
}
.stat-card-val.green { color: var(--go); }
.stat-card-val.red { color: var(--stop); }
.stat-card-val.amber { color: var(--warn); }
.stat-card-val.blue { color: var(--blue); }
.stat-card-label { font-size: 0.68rem; color: var(--muted); }

/* Crossing time bar */
.time-bar-wrap {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.time-row { display: flex; align-items: center; justify-content: space-between; }
.time-bar {
  height: 6px;
  background: var(--surface2);
  border-radius: 3px;
  overflow: hidden;
}
.time-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 1s linear, background 0.3s;
}
.time-label { font-size: 0.72rem; color: var(--muted); }
.time-val { font-family: var(--font-mono); font-size: 0.8rem; font-weight: 500; }

/* Detections */
.detection-list {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-height: 0;
}
.detection-list::-webkit-scrollbar { width:3px; }
.detection-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); }

.det-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 5px;
  font-size: 0.72rem;
  animation: fadeSlide 0.3s ease-out;
}
@keyframes fadeSlide { from{opacity:0;transform:translateX(8px)}to{opacity:1;transform:none} }

.det-icon { font-size: 1rem; flex-shrink: 0; }
.det-info { flex: 1; }
.det-name { font-weight: 500; color: var(--text); }
.det-sub { color: var(--muted); font-size: 0.65rem; }
.det-time { font-family: var(--font-mono); font-size: 0.6rem; color: var(--muted); margin-left: auto; flex-shrink: 0; }
.det-conf {
  font-family: var(--font-mono);
  font-size: 0.62rem;
  padding: 1px 5px;
  border-radius: 3px;
  flex-shrink: 0;
}
.det-conf.normal { background: rgba(34,197,94,0.12); color: var(--go); }
.det-conf.mobility { background: rgba(59,130,246,0.12); color: var(--blue); }
.det-conf.jay { background: rgba(239,68,68,0.12); color: var(--stop); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PAGE 2 â€” LOG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#page-log {
  flex-direction: column;
  overflow: hidden;
}
.log-page-header {
  padding: 20px 28px 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-shrink: 0;
}
.log-page-title {
  font-family: var(--font-display);
  font-size: 1.3rem;
  font-weight: 700;
}
.log-filters {
  display: flex;
  gap: 6px;
}
.filter-btn {
  padding: 5px 12px;
  border-radius: 20px;
  border: 1px solid var(--border);
  background: transparent;
  color: var(--muted);
  font-family: var(--font-body);
  font-size: 0.72rem;
  cursor: pointer;
  transition: all 0.15s;
}
.filter-btn.active, .filter-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}
.log-table-wrap { flex: 1; overflow-y: auto; padding: 0 28px 20px; }
.log-table-wrap::-webkit-scrollbar { width: 4px; }
.log-table-wrap::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.08); }

table { width: 100%; border-collapse: collapse; }
th {
  text-align: left;
  font-size: 0.65rem;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--muted);
  padding: 12px 12px 8px;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 5;
}
td {
  padding: 10px 12px;
  font-size: 0.78rem;
  border-bottom: 1px solid rgba(255,255,255,0.03);
  vertical-align: middle;
}
tr:hover td { background: rgba(255,255,255,0.02); }
.log-type-pill {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 0.67rem;
  font-weight: 500;
}
.pill-normal { background: rgba(34,197,94,0.1); color: var(--go); }
.pill-mobility { background: rgba(59,130,246,0.1); color: var(--blue); }
.pill-jaywalk { background: rgba(239,68,68,0.1); color: var(--stop); }
.pill-timeout { background: rgba(245,158,11,0.1); color: var(--warn); }

.log-mono { font-family: var(--font-mono); font-size: 0.72rem; color: var(--muted); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PAGE 3 â€” ADMIN SETTINGS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#page-admin {
  flex-direction: row;
  overflow: hidden;
}

.admin-nav {
  width: 200px;
  background: var(--surface);
  border-right: 1px solid var(--border);
  padding: 16px 0;
  display: flex;
  flex-direction: column;
  gap: 2px;
  flex-shrink: 0;
}
.admin-nav-item {
  padding: 9px 20px;
  font-size: 0.78rem;
  color: var(--muted);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 9px;
  transition: all 0.15s;
  border-left: 2px solid transparent;
}
.admin-nav-item:hover { color: var(--text); background: rgba(255,255,255,0.02); }
.admin-nav-item.active { color: var(--text); background: rgba(245,166,35,0.06); border-left-color: var(--accent); }

.admin-content {
  flex: 1;
  overflow-y: auto;
  padding: 24px 32px;
}
.admin-content::-webkit-scrollbar { width:4px; }
.admin-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.08); }

.admin-panel { display: none; }
.admin-panel.active { display: block; }

.admin-h1 {
  font-family: var(--font-display);
  font-size: 1.2rem;
  font-weight: 700;
  margin-bottom: 4px;
}
.admin-sub {
  font-size: 0.78rem;
  color: var(--muted);
  margin-bottom: 24px;
}

.settings-group {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  overflow: hidden;
  margin-bottom: 16px;
}
.settings-group-title {
  padding: 12px 16px;
  font-size: 0.72rem;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--muted);
  border-bottom: 1px solid var(--border);
  background: var(--surface2);
}
.setting-row {
  display: flex;
  align-items: center;
  padding: 14px 16px;
  border-bottom: 1px solid var(--border);
  gap: 16px;
}
.setting-row:last-child { border-bottom: none; }
.setting-label { flex: 1; }
.setting-label-text { font-size: 0.82rem; font-weight: 500; margin-bottom: 2px; }
.setting-label-desc { font-size: 0.7rem; color: var(--muted); }

/* Toggle */
.toggle {
  width: 40px; height: 22px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 11px;
  cursor: pointer;
  position: relative;
  transition: all 0.2s;
  flex-shrink: 0;
}
.toggle.on { background: var(--accent); border-color: var(--accent); }
.toggle-thumb {
  width: 16px; height: 16px;
  background: rgba(255,255,255,0.4);
  border-radius: 50%;
  position: absolute;
  top: 2px; left: 2px;
  transition: all 0.2s;
}
.toggle.on .toggle-thumb { left: 20px; background: #000; }

/* Range slider */
.range-wrap { display: flex; align-items: center; gap: 10px; }
input[type=range] {
  width: 120px;
  accent-color: var(--accent);
  cursor: pointer;
}
.range-val {
  font-family: var(--font-mono);
  font-size: 0.78rem;
  min-width: 40px;
  text-align: right;
}

/* Crosswalk canvas */
.crosswalk-editor {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  overflow: hidden;
  margin-bottom: 16px;
}
.crosswalk-editor-header {
  padding: 12px 16px;
  background: var(--surface2);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}
#crosswalk-canvas {
  display: block;
  cursor: crosshair;
  width: 100%;
}
.editor-tools {
  display: flex;
  gap: 6px;
  align-items: center;
  padding: 10px 16px;
  border-top: 1px solid var(--border);
  flex-wrap: wrap;
}

.tool-btn {
  padding: 5px 12px;
  border-radius: 5px;
  border: 1px solid var(--border);
  background: transparent;
  color: var(--text);
  font-family: var(--font-body);
  font-size: 0.72rem;
  cursor: pointer;
  transition: all 0.15s;
}
.tool-btn:hover, .tool-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(245,166,35,0.06); }
.tool-btn.clear { border-color: rgba(239,68,68,0.3); color: var(--stop); }
.tool-btn.clear:hover { background: rgba(239,68,68,0.06); }

.zone-legend {
  display: flex;
  gap: 12px;
  padding: 10px 16px;
  font-size: 0.7rem;
  color: var(--muted);
  border-top: 1px solid var(--border);
  flex-wrap: wrap;
}
.zone-legend-item { display:flex; align-items:center; gap:5px; }
.zone-dot { width:10px; height:10px; border-radius:50%; }

.sim-view-option-active { border-color: var(--accent) !important; background: rgba(245,166,35,0.06) !important; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#page-sim {
  flex-direction: row;
  overflow: hidden;
  background: var(--bg);
}
.sim-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
}
#sim-canvas {
  flex: 1;
  display: block;
  width: 100%;
  min-height: 0;
  background: #0a0c10;
  cursor: default;
}
.sim-bottom-bar {
  height: 52px;
  background: var(--surface);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 16px;
  gap: 10px;
  flex-shrink: 0;
  overflow-x: auto;
}
.sim-bottom-bar::-webkit-scrollbar { display:none; }
.sim-section-label {
  font-size: 0.6rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--muted);
  white-space: nowrap;
}
.sim-divider { width:1px; height:24px; background:var(--border); flex-shrink:0; }
.sim-sidebar {
  width: 260px;
  background: var(--surface);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  flex-shrink: 0;
}
.sim-sidebar-section {
  padding: 14px 16px;
  border-bottom: 1px solid var(--border);
}
.sim-signal-display {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 14px;
  background: var(--surface2);
  border-radius: 8px;
  margin-bottom: 8px;
}
.sim-light-stack {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3px;
  background: #111;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 6px;
  padding: 6px 8px;
}
.sim-bulb {
  width: 18px; height: 18px;
  border-radius: 50%;
  background: rgba(255,255,255,0.06);
  transition: all 0.3s;
}
.sim-bulb.red.on   { background: #ef4444; box-shadow: 0 0 10px #ef4444; }
.sim-bulb.yellow.on{ background: #f59e0b; box-shadow: 0 0 10px #f59e0b; }
.sim-bulb.green.on { background: #22c55e; box-shadow: 0 0 10px #22c55e; }
.sim-ped-signal { flex:1; text-align:center; }
.sim-ped-icon { font-size: 2rem; }
.sim-ped-icon.walk { animation: walkAnim 0.5s infinite alternate; }
.sim-countdown {
  font-family: var(--font-mono);
  font-size: 1.6rem;
  font-weight: 500;
  line-height: 1;
  margin-top: 4px;
}
.sim-phase-tag {
  font-size: 0.62rem;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  padding: 2px 7px;
  border-radius: 3px;
  margin-top: 5px;
  display: inline-block;
}
.phase-tag-go   { background: rgba(34,197,94,0.15); color: var(--go); }
.phase-tag-stop { background: rgba(239,68,68,0.15); color: var(--stop); }
.phase-tag-warn { background: rgba(245,158,11,0.15); color: var(--warn); }
.sim-car-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 7px 10px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 0.72rem;
  margin-bottom: 5px;
}
.sim-car-color { width:14px; height:10px; border-radius:2px; flex-shrink:0; }
.sim-car-label { flex:1; }
.sim-car-speed { font-family:var(--font-mono); font-size:0.66rem; color:var(--muted); }
.sim-car-state { font-size:0.62rem; padding:1px 6px; border-radius:10px; }
.state-moving { background:rgba(34,197,94,0.12); color:var(--go); }
.state-stopped { background:rgba(239,68,68,0.12); color:var(--stop); }
.state-slowing { background:rgba(245,158,11,0.12); color:var(--warn); }
.sim-queue-bar-wrap { display:flex; align-items:center; gap:6px; margin-bottom:4px; }
.sim-queue-label { font-size:0.68rem; color:var(--muted); min-width:18px; }
.sim-queue-bar { flex:1; height:8px; background:var(--surface2); border-radius:4px; overflow:hidden; }
.sim-queue-fill { height:100%; border-radius:4px; transition:width 0.4s ease; }
.sim-event-list {
  flex:1;
  overflow-y:auto;
  padding: 8px 16px;
  display:flex;
  flex-direction:column;
  gap:3px;
  min-height:0;
}
.sim-event-list::-webkit-scrollbar { width:3px; }
.sim-event-list::-webkit-scrollbar-thumb { background:rgba(255,255,255,0.08); }
.sim-evt { font-size:0.68rem; color:var(--muted); display:flex; gap:6px; line-height:1.4; }
.sim-evt-time { font-family:var(--font-mono); color:rgba(255,255,255,0.2); flex-shrink:0; font-size:0.6rem; }
.sim-evt.highlight { color:var(--text); }
.sim-evt.go-evt { color:var(--go); }
.sim-evt.stop-evt { color:var(--stop); }
.sim-evt.warn-evt { color:var(--warn); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ANNOUNCEMENT TOAST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#announcement-toast {
  position: fixed;
  bottom: 70px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  background: rgba(10,12,18,0.95);
  border: 1px solid var(--accent);
  border-radius: 10px;
  padding: 12px 20px;
  font-size: 0.82rem;
  font-weight: 500;
  color: var(--text);
  z-index: 1000;
  opacity: 0;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  gap: 10px;
  backdrop-filter: blur(10px);
  max-width: 400px;
  text-align: center;
  pointer-events: none;
}
#announcement-toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
#announcement-toast .toast-icon { font-size: 1.2rem; }

/* â”€â”€ Pedestrian Waiting Cue (shown during vehicle green) â”€â”€ */
#ped-waiting-cue {
  position: absolute;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  display: none;
  align-items: center;
  gap: 8px;
  background: rgba(245,166,35,0.12);
  border: 1px solid rgba(245,166,35,0.5);
  border-radius: 8px;
  padding: 8px 16px;
  font-size: 0.78rem;
  font-weight: 500;
  color: var(--accent);
  pointer-events: none;
  animation: pwcPulse 1.5s ease-in-out infinite;
  backdrop-filter: blur(6px);
  z-index: 10;
}
@keyframes pwcPulse {
  0%,100%{box-shadow:0 0 0 0 rgba(245,166,35,0)} 50%{box-shadow:0 0 0 6px rgba(245,166,35,0.15)}
}
.pwc-icon { font-size: 1.1rem; }
.pwc-count { font-family: var(--font-mono); font-size: 1rem; color: #fff; font-weight: 700; }
.pwc-label { opacity: 0.85; }

</style>
</head>
<body>

<!-- â”€â”€ NAVIGATION â”€â”€ -->
<nav>
  <div class="nav-logo">ğŸ” Hen-<span>Tersection</span></div>
  <div class="nav-tab live active" data-page="live" onclick="switchPage('live',this)">
    <div class="dot"></div> Live Monitor
  </div>
  <div class="nav-tab" data-page="log" onclick="switchPage('log',this)">
    ğŸ“‹ Event Log
  </div>
  <div class="nav-tab" data-page="sim" onclick="switchPage('sim',this); setTimeout(()=>{if(!simRunning){document.getElementById('sim-toggle-btn').click();}},150)">
    ğŸš— Traffic Sim
  </div>
  <div class="nav-tab" data-page="admin" onclick="switchPage('admin',this)">
    âš™ï¸ Admin Settings
  </div>
  <div class="nav-right">
    <span class="badge green" id="model-badge">â— Loading modelâ€¦</span>
    <span class="badge" id="time-badge">--:--:--</span>
  </div>
</nav>

<!-- â•â•â•â•â•â•â•â•â•â•â• PAGE: LIVE â•â•â•â•â•â•â•â•â•â•â• -->
<div class="page active" id="page-live">
  <div class="live-main">
    <div class="camera-container">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="canvas"></canvas>
      <div class="cam-overlay">
        <div class="cam-corner tl"></div>
        <div class="cam-corner tr"></div>
        <div class="cam-corner bl"></div>
        <div class="cam-corner br"></div>
        <div class="cam-rec"><div class="rec-dot"></div> LIVE</div>
        <div class="cam-info" id="cam-info">INITIALIZINGâ€¦</div>
        <div class="cam-fps" id="cam-fps">-- FPS</div>
        <!-- Pedestrian waiting cue (shown during vehicle green when peds detected) -->
        <div id="ped-waiting-cue">
          <span class="pwc-icon">ğŸ‘</span>
          <span class="pwc-count">0</span>
          <span class="pwc-label">pedestrian(s) waiting â€” reducing green timer</span>
        </div>
      </div>


    </div>

    <!-- Bottom controls bar -->
    <div class="cam-bottom-bar">
      <div class="voice-indicator" id="voice-indicator">
        <div class="voice-bars" id="voice-bars">
          <div class="voice-bar" style="height:6px"></div>
          <div class="voice-bar" style="height:10px"></div>
          <div class="voice-bar" style="height:8px"></div>
          <div class="voice-bar" style="height:12px"></div>
          <div class="voice-bar" style="height:6px"></div>
        </div>
        <span id="voice-text" style="font-size:0.72rem; color:var(--muted)">No speech</span>
      </div>
      <select id="camera-select" style="
        background:var(--surface2); border:1px solid var(--border); border-radius:6px;
        color:var(--text); font-family:var(--font-body); font-size:0.75rem;
        padding:6px 10px; cursor:pointer; max-width:220px; outline:none;
      ">
        <option value="">ğŸ“· Default Camera</option>
      </select>
      <button class="btn" id="refresh-cams-btn" onclick="enumerateCameras()" title="Refresh camera list" style="padding:6px 10px; font-size:0.8rem;">âŸ³</button>
      <button class="btn primary" id="start-btn" onclick="startCamera()">â–¶ Start Camera</button>
      <button class="btn danger" id="stop-btn" onclick="stopCamera()" disabled>â–  Stop</button>
      <button class="btn" onclick="triggerCrossNow()">ğŸš¶ Trigger Cross</button>
    </div>
  </div>

  <!-- Right sidebar -->
  <div class="live-sidebar">
    <div class="sidebar-section">
      <div class="section-label">Signal Status</div>
      <div style="display:flex; gap:16px; justify-content:center; padding:8px 0;">
        <div class="traffic-light">
          <div class="light-label">VEHICLE</div>
          <div class="lights">
            <div class="light-bulb red" id="light-red"></div>
            <div class="light-bulb yellow" id="light-yellow"></div>
            <div class="light-bulb green" id="light-green"></div>
          </div>
        </div>
        <div class="walk-signal">
          <div class="light-label">PEDESTRIAN</div>
          <div class="walk-icon" id="walk-icon">ğŸš¶</div>
          <div class="countdown-ring" id="countdown-ring">
            <svg viewBox="0 0 48 48">
              <circle class="ring-track" cx="24" cy="24" r="20"/>
              <circle class="ring-fill" id="ring-fill" cx="24" cy="24" r="20"
                stroke-dasharray="125.7" stroke-dashoffset="0" stroke="#22c55e"/>
            </svg>
            <span class="countdown-num" id="countdown-num">--</span>
          </div>
        </div>
      </div>
    </div>

    <div class="sidebar-section">
      <div class="section-label">Crossing Timer</div>
      <div class="time-bar-wrap">
        <div class="time-row">
          <span class="time-label">Time Remaining</span>
          <span class="time-val" id="timer-val">--s</span>
        </div>
        <div class="time-bar">
          <div class="time-bar-fill" id="time-bar-fill" style="width:0%; background: var(--go);"></div>
        </div>
        <div class="time-row" style="margin-top:4px">
          <span class="time-label" style="font-size:0.67rem">Phase</span>
          <span class="time-val" style="font-size:0.7rem; color:var(--muted)" id="phase-label">Waiting</span>
        </div>
      </div>
    </div>

    <div class="sidebar-section" style="flex:1; overflow:hidden; display:flex; flex-direction:column;">
      <div class="section-label">Detections</div>
      <div class="detection-list" id="detection-list">
        <div style="color:var(--muted); font-size:0.72rem; text-align:center; padding:20px">Camera not started</div>
      </div>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â• PAGE: LOG â•â•â•â•â•â•â•â•â•â•â• -->
<div class="page" id="page-log">
  <div class="log-page-header">
    <div>
      <div class="log-page-title">Event Log</div>
      <div style="font-size:0.75rem; color:var(--muted); margin-top:2px">All pedestrian crossings & incidents</div>
    </div>
    <div style="display:flex; align-items:center; gap:16px;">
      <div class="stats-grid" style="display:flex; gap:8px;">
        <div class="stat-card">
          <div class="stat-card-val green" id="stat-crossed">0</div>
          <div class="stat-card-label">Crossed Today</div>
        </div>
        <div class="stat-card">
          <div class="stat-card-val red" id="stat-jay">0</div>
          <div class="stat-card-label">Jaywalkers</div>
        </div>
        <div class="stat-card">
          <div class="stat-card-val blue" id="stat-mobility">0</div>
          <div class="stat-card-label">Mobility Assists</div>
        </div>
        <div class="stat-card">
          <div class="stat-card-val amber" id="stat-avgtime">--s</div>
          <div class="stat-card-label">Avg Cross Time</div>
        </div>
      </div>
      <div class="log-filters">
        <button class="filter-btn active" onclick="filterLog('all',this)">All</button>
        <button class="filter-btn" onclick="filterLog('normal',this)">Normal</button>
        <button class="filter-btn" onclick="filterLog('mobility',this)">Mobility Aid</button>
        <button class="filter-btn" onclick="filterLog('jaywalk',this)">Jaywalkers</button>
      </div>
      <button class="btn" onclick="exportLog()">â†“ Export CSV</button>
    </div>
  </div>
  <div class="log-table-wrap">
    <table>
      <thead>
        <tr>
          <th>Time</th>
          <th>Event Type</th>
          <th>Persons</th>
          <th>Cross Time</th>
          <th>Confidence</th>
          <th>Notes</th>
        </tr>
      </thead>
      <tbody id="log-tbody">
        <tr><td colspan="6" style="text-align:center; color:var(--muted); padding:40px;">No events yet â€” start the camera</td></tr>
      </tbody>
    </table>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â• PAGE: SIMULATION â•â•â•â•â•â•â•â•â•â•â• -->
<div class="page" id="page-sim">
  <div class="sim-main">
    <canvas id="sim-canvas"></canvas>
    <div class="sim-bottom-bar">
      <span class="sim-section-label">Traffic Flow</span>
      <button class="btn primary" id="sim-toggle-btn" onclick="toggleSim()">â–¶ Start Simulation</button>
      <button class="btn" onclick="spawnCarManual('horizontal')">+ Spawn Car (EW)</button>
      <button class="btn" onclick="spawnCarManual('vertical')">+ Spawn Car (NS)</button>
      <div class="sim-divider"></div>
      <span class="sim-section-label">Speed</span>
      <input type="range" min="0.3" max="3" step="0.1" value="1" id="sim-speed-slider" oninput="simSpeed=parseFloat(this.value); document.getElementById('sim-speed-val').textContent=this.value+'Ã—'">
      <span id="sim-speed-val" style="font-family:var(--font-mono);font-size:0.72rem;min-width:30px">1Ã—</span>
      <div class="sim-divider"></div>
      <span class="sim-section-label">Density</span>
      <input type="range" min="1" max="5" step="1" value="2" id="sim-density" oninput="document.getElementById('sim-density-val').textContent=['Low','Med-Low','Medium','Med-High','High'][this.value-1]">
      <span id="sim-density-val" style="font-size:0.72rem;color:var(--muted);min-width:60px">Med-Low</span>
      <div class="sim-divider"></div>
      <button class="btn" onclick="triggerCrossNow(); addSimEvent('ğŸš¶ Manual pedestrian crossing triggered','highlight')">ğŸš¶ Trigger Cross</button>
    </div>
  </div>

  <!-- Right sidebar -->
  <div class="sim-sidebar">
    <div class="sim-sidebar-section">
      <div class="section-label" style="margin-bottom:10px">Signal Status</div>
      <div class="sim-signal-display">
        <div class="sim-light-stack">
          <div style="font-size:0.5rem;color:rgba(255,255,255,0.3);letter-spacing:.08em;margin-bottom:3px">VEH</div>
          <div class="sim-bulb red" id="sbulb-red"></div>
          <div class="sim-bulb yellow" id="sbulb-yellow"></div>
          <div class="sim-bulb green" id="sbulb-green"></div>
        </div>
        <div class="sim-ped-signal">
          <div class="sim-ped-icon" id="sim-ped-icon">ğŸ›‘</div>
          <div class="sim-countdown" id="sim-countdown">--</div>
          <div class="sim-phase-tag phase-tag-stop" id="sim-phase-tag">Vehicle Green</div>
        </div>
        <div class="sim-light-stack">
          <div style="font-size:0.5rem;color:rgba(255,255,255,0.3);letter-spacing:.08em;margin-bottom:3px">VEH</div>
          <div class="sim-bulb red" id="sbulb-red2"></div>
          <div class="sim-bulb yellow" id="sbulb-yellow2"></div>
          <div class="sim-bulb green" id="sbulb-green2"></div>
        </div>
      </div>
    </div>

    <div class="sim-sidebar-section">
      <div class="section-label" style="margin-bottom:10px">Queue Length</div>
      <div id="sim-queue-display">
        <div class="sim-queue-bar-wrap">
          <span class="sim-queue-label">â†’</span>
          <div class="sim-queue-bar"><div class="sim-queue-fill" id="q-east" style="width:0%;background:#3b82f6"></div></div>
          <span style="font-family:var(--font-mono);font-size:0.65rem;min-width:16px" id="q-east-n">0</span>
        </div>
        <div class="sim-queue-bar-wrap">
          <span class="sim-queue-label">â†</span>
          <div class="sim-queue-bar"><div class="sim-queue-fill" id="q-west" style="width:0%;background:#8b5cf6"></div></div>
          <span style="font-family:var(--font-mono);font-size:0.65rem;min-width:16px" id="q-west-n">0</span>
        </div>
        <div class="sim-queue-bar-wrap">
          <span class="sim-queue-label">â†“</span>
          <div class="sim-queue-bar"><div class="sim-queue-fill" id="q-south" style="width:0%;background:#f5a623"></div></div>
          <span style="font-family:var(--font-mono);font-size:0.65rem;min-width:16px" id="q-south-n">0</span>
        </div>
        <div class="sim-queue-bar-wrap">
          <span class="sim-queue-label">â†‘</span>
          <div class="sim-queue-bar"><div class="sim-queue-fill" id="q-north" style="width:0%;background:#22c55e"></div></div>
          <span style="font-family:var(--font-mono);font-size:0.65rem;min-width:16px" id="q-north-n">0</span>
        </div>
      </div>
    </div>

    <div class="sim-sidebar-section" style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
      <div style="background:var(--surface2);border:1px solid var(--border);border-radius:6px;padding:10px">
        <div style="font-family:var(--font-mono);font-size:1.3rem;color:var(--go)" id="sim-stat-passed">0</div>
        <div style="font-size:0.66rem;color:var(--muted)">Cars Passed</div>
      </div>
      <div style="background:var(--surface2);border:1px solid var(--border);border-radius:6px;padding:10px">
        <div style="font-family:var(--font-mono);font-size:1.3rem;color:var(--warn)" id="sim-stat-stopped">0</div>
        <div style="font-size:0.66rem;color:var(--muted)">Total Stops</div>
      </div>
      <div style="background:var(--surface2);border:1px solid var(--border);border-radius:6px;padding:10px">
        <div style="font-family:var(--font-mono);font-size:1.3rem;color:var(--blue)" id="sim-stat-avgwait">0s</div>
        <div style="font-size:0.66rem;color:var(--muted)">Avg Wait</div>
      </div>
      <div style="background:var(--surface2);border:1px solid var(--border);border-radius:6px;padding:10px">
        <div style="font-family:var(--font-mono);font-size:1.3rem;color:var(--accent)" id="sim-stat-active">0</div>
        <div style="font-size:0.66rem;color:var(--muted)">Active Cars</div>
      </div>
    </div>

    <div class="sim-sidebar-section" style="flex-shrink:0">
      <div class="section-label" style="margin-bottom:8px">Simulation Log</div>
    </div>
    <div class="sim-event-list" id="sim-event-list">
      <div class="sim-evt" style="color:var(--muted);text-align:center;padding:10px">Start simulation to begin</div>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â• PAGE: ADMIN â•â•â•â•â•â•â•â•â•â•â• -->
<div class="page" id="page-admin">
  <div class="admin-nav">
    <div class="admin-nav-item active" onclick="switchAdminPanel('timing',this)">â± Timing</div>
    <div class="admin-nav-item" onclick="switchAdminPanel('detection',this)">ğŸ‘ Detection</div>
    <div class="admin-nav-item" onclick="switchAdminPanel('voice',this)">ğŸ”Š Voice / Alerts</div>
    <div class="admin-nav-item" onclick="switchAdminPanel('zones',this)">ğŸ“ Crossing Zones</div>
    <div class="admin-nav-item" onclick="switchAdminPanel('signals',this)">ğŸš¦ Signal Config</div>
    <div class="admin-nav-item" onclick="switchAdminPanel('simview',this)">ğŸ—º Simulation View</div>
    <div class="admin-nav-item" onclick="switchAdminPanel('snowflake',this)">â„ Snowflake DB</div>
  </div>

  <div class="admin-content">

    <!-- TIMING -->
    <div class="admin-panel active" id="panel-timing">
      <div class="admin-h1">Timing Configuration</div>
      <div class="admin-sub">Control crossing durations and adaptive adjustment settings</div>

      <div class="settings-group">
        <div class="settings-group-title">Base Timings</div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Default Crossing Time</div>
            <div class="setting-label-desc">Standard green phase for pedestrians</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="10" max="60" value="20" id="r-default-time" oninput="updateRange('r-default-time','rv-default-time','s',v=>v)">
            <span class="range-val" id="rv-default-time">20s</span>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Mobility Aid Extension</div>
            <div class="setting-label-desc">Extra time added when wheelchair/cane detected</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="5" max="30" value="15" id="r-mobility-ext" oninput="updateRange('r-mobility-ext','rv-mobility-ext','s',v=>v)">
            <span class="range-val" id="rv-mobility-ext">15s</span>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Warning Countdown Start</div>
            <div class="setting-label-desc">Seconds before end to flash warning</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="3" max="15" value="7" id="r-warn-start" oninput="updateRange('r-warn-start','rv-warn-start','s',v=>v)">
            <span class="range-val" id="rv-warn-start">7s</span>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Minimum Wait Reduction</div>
            <div class="setting-label-desc">Max % that smart timing can cut the wait time</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="0" max="70" value="40" id="r-min-wait" oninput="updateRange('r-min-wait','rv-min-wait','%',v=>v)">
            <span class="range-val" id="rv-min-wait">40%</span>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title">Adaptive Timing</div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Smart Queue Detection</div>
            <div class="setting-label-desc">Trigger crossing earlier when queue > 3 persons</div>
          </div>
          <div class="toggle on" id="t-smart-queue" onclick="toggleSetting(this)">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Extend for Slow Crossers</div>
            <div class="setting-label-desc">Add time if person is still in road near end</div>
          </div>
          <div class="toggle on" id="t-slow-extend" onclick="toggleSetting(this)">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Peak Hour Boost</div>
            <div class="setting-label-desc">Auto-increase crossing time 7-9am & 5-7pm</div>
          </div>
          <div class="toggle" id="t-peak" onclick="toggleSetting(this)">
            <div class="toggle-thumb"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- DETECTION -->
    <div class="admin-panel" id="panel-detection">
      <div class="admin-h1">Detection Settings</div>
      <div class="admin-sub">Configure AI detection thresholds and person classification</div>

      <div class="settings-group">
        <div class="settings-group-title">Confidence Thresholds</div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Person Detection Threshold</div>
            <div class="setting-label-desc">Min confidence to count as a person</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="30" max="95" value="55" id="r-person-thresh" oninput="updateRange('r-person-thresh','rv-person-thresh','%',v=>v)">
            <span class="range-val" id="rv-person-thresh">55%</span>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Mobility Aid Sensitivity</div>
            <div class="setting-label-desc">How aggressively to flag wheelchair/cane</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="1" max="5" value="3" id="r-mob-sens" oninput="updateRange('r-mob-sens','rv-mob-sens','',v=>['Low','Med-Low','Medium','Med-High','High'][v-1])">
            <span class="range-val" id="rv-mob-sens">Medium</span>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title">Jaywalking Detection</div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Enable Jaywalker Logging</div>
            <div class="setting-label-desc">Log crossings that occur outside crossing zone</div>
          </div>
          <div class="toggle on" id="t-jay-log" onclick="toggleSetting(this)">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Jaywalker Alert Sound</div>
            <div class="setting-label-desc">Play alert when jaywalker detected</div>
          </div>
          <div class="toggle" id="t-jay-alert" onclick="toggleSetting(this)">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Red-phase Detection Buffer</div>
            <div class="setting-label-desc">Seconds after light change before flagging</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="0" max="10" value="3" id="r-jay-buffer" oninput="updateRange('r-jay-buffer','rv-jay-buffer','s',v=>v)">
            <span class="range-val" id="rv-jay-buffer">3s</span>
          </div>
        </div>
      </div>
    </div>

    <!-- VOICE -->
    <div class="admin-panel" id="panel-voice">
      <div class="admin-h1">Voice & Alerts</div>
      <div class="admin-sub">Configure verbal announcements and audio alerts</div>

      <div class="settings-group">
        <div class="settings-group-title">Text-to-Speech</div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Enable Voice Announcements</div>
            <div class="setting-label-desc">Verbally instruct pedestrians using TTS</div>
          </div>
          <div class="toggle on" id="t-voice" onclick="toggleSetting(this)">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Speech Rate</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="5" max="15" value="9" id="r-speech-rate" oninput="updateRange('r-speech-rate','rv-speech-rate','',v=>(v/10).toFixed(1))">
            <span class="range-val" id="rv-speech-rate">0.9</span>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Voice Volume</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="0" max="10" value="9" id="r-vol" oninput="updateRange('r-vol','rv-vol','',v=>(v/10).toFixed(1))">
            <span class="range-val" id="rv-vol">0.9</span>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title">Announcement Messages</div>
        <div class="setting-row" style="flex-direction:column; align-items:flex-start; gap:8px">
          <div class="setting-label-text">Walk Signal Message</div>
          <input type="text" id="msg-walk" value="Walk signal is on. It is safe to cross." style="width:100%; background:var(--surface2); border:1px solid var(--border); border-radius:5px; padding:8px 12px; color:var(--text); font-family:var(--font-body); font-size:0.8rem;">
        </div>
        <div class="setting-row" style="flex-direction:column; align-items:flex-start; gap:8px">
          <div class="setting-label-text">Mobility Aid Message</div>
          <input type="text" id="msg-mobility" value="Extended crossing time activated. Please cross carefully." style="width:100%; background:var(--surface2); border:1px solid var(--border); border-radius:5px; padding:8px 12px; color:var(--text); font-family:var(--font-body); font-size:0.8rem;">
        </div>
        <div class="setting-row" style="flex-direction:column; align-items:flex-start; gap:8px">
          <div class="setting-label-text">Warning Message (last 7s)</div>
          <input type="text" id="msg-warn" value="Warning. Signal changing soon. Please finish crossing." style="width:100%; background:var(--surface2); border:1px solid var(--border); border-radius:5px; padding:8px 12px; color:var(--text); font-family:var(--font-body); font-size:0.8rem;">
        </div>
        <div class="setting-row" style="flex-direction:column; align-items:flex-start; gap:8px">
          <div class="setting-label-text">Do Not Cross Message</div>
          <input type="text" id="msg-stop" value="Do not cross. Wait for the walk signal." style="width:100%; background:var(--surface2); border:1px solid var(--border); border-radius:5px; padding:8px 12px; color:var(--text); font-family:var(--font-body); font-size:0.8rem;">
        </div>
      </div>

      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn" onclick="testSpeak('walk')">ğŸ”Š Test Walk</button>
        <button class="btn" onclick="testSpeak('mobility')">ğŸ”Š Test Mobility</button>
        <button class="btn" onclick="testSpeak('warn')">ğŸ”Š Test Warning</button>
        <button class="btn" onclick="testSpeak('stop')">ğŸ”Š Test Stop</button>
      </div>
    </div>

    <!-- ZONES -->
    <div class="admin-panel" id="panel-zones">
      <div class="admin-h1">Crossing Zones</div>
      <div class="admin-sub">Define detection zones on the street-level camera view. The horizon line divides the pavement (top) from the road (bottom). Jaywalker detection triggers when a person enters the road region during a red phase.</div>

      <div class="crosswalk-editor">
        <div class="crosswalk-editor-header">
          <span style="font-size:0.78rem; font-weight:500">Zone Editor â€” Street-Level View</span>
          <span style="font-size:0.7rem; color:var(--muted)" id="zone-count">0 zones defined</span>
        </div>
        <canvas id="crosswalk-canvas" width="800" height="350"></canvas>
        <div class="editor-tools">
          <button class="tool-btn active" id="tool-cross" onclick="setTool('crosswalk',this)">+ Crosswalk Zone</button>
          <button class="tool-btn" id="tool-wait" onclick="setTool('wait',this)">+ Wait Zone</button>
          <button class="tool-btn" id="tool-line" onclick="setTool('line',this)">+ Crossing Line</button>
          <button class="tool-btn" id="tool-select" onclick="setTool('select',this)">â†– Select / Move</button>
          <button class="tool-btn clear" onclick="clearZones()">âœ• Clear All</button>
        </div>
        <div class="zone-legend">
          <span class="zone-legend-item"><span class="zone-dot" style="background:rgba(34,197,94,0.6)"></span> Crosswalk Zone</span>
          <span class="zone-legend-item"><span class="zone-dot" style="background:rgba(59,130,246,0.6)"></span> Wait Zone</span>
          <span class="zone-legend-item"><span class="zone-dot" style="background:rgba(245,158,11,0.6)"></span> Crossing Line</span>
          <span style="color:var(--muted); font-size:0.67rem; margin-left:auto">Click and drag to draw â€¢ Double-click to delete</span>
        </div>
      </div>
    </div>

    <!-- SIGNALS -->
    <div class="admin-panel" id="panel-signals">
      <div class="admin-h1">Signal Configuration</div>
      <div class="admin-sub">Configure traffic light phases and pedestrian signal behavior</div>

      <div class="settings-group">
        <div class="settings-group-title">Signal Timing</div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Vehicle Red Phase</div>
            <div class="setting-label-desc">How long vehicles stop (pedestrians walk)</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="15" max="90" value="30" id="r-red-phase" oninput="updateRange('r-red-phase','rv-red-phase','s',v=>v)">
            <span class="range-val" id="rv-red-phase">30s</span>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Yellow Transition Phase</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="2" max="8" value="4" id="r-yellow-phase" oninput="updateRange('r-yellow-phase','rv-yellow-phase','s',v=>v)">
            <span class="range-val" id="rv-yellow-phase">4s</span>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Vehicle Green Phase</div>
          </div>
          <div class="range-wrap">
            <input type="range" min="15" max="120" value="45" id="r-green-phase" oninput="updateRange('r-green-phase','rv-green-phase','s',v=>v)">
            <span class="range-val" id="rv-green-phase">45s</span>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title">Pedestrian Signal Options</div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Flashing Don't Walk (last 5s)</div>
          </div>
          <div class="toggle on" id="t-flash-dw" onclick="toggleSetting(this)">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Audible Beep on Walk Signal</div>
          </div>
          <div class="toggle on" id="t-beep" onclick="toggleSetting(this)">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Demand-Responsive Mode</div>
            <div class="setting-label-desc">Only cycle pedestrian phase when persons waiting</div>
          </div>
          <div class="toggle on" id="t-demand" onclick="toggleSetting(this)">
            <div class="toggle-thumb"></div>
          </div>
        </div>
      </div>

      <div style="margin-top:8px">
        <button class="btn primary" onclick="saveSettings()">ğŸ’¾ Save All Settings</button>
      </div>
    </div>

    <!-- SIMULATION VIEW -->
    <div class="admin-panel" id="panel-simview">
      <div class="admin-h1">Simulation View</div>
      <div class="admin-sub">Choose how the traffic simulation is displayed â€” intersection view, single road, or side-on street view</div>

      <div class="settings-group">
        <div class="settings-group-title">Road Layout</div>
        <div class="setting-row" style="align-items:flex-start; flex-direction:column; gap:14px; padding:16px">
          <div style="display:flex; flex-direction:column; gap:10px; width:100%">
            <label style="display:flex; align-items:center; gap:12px; cursor:pointer; padding:12px 14px; background:var(--surface2); border:2px solid var(--border); border-radius:8px; transition:border-color 0.2s" id="view-opt-intersection" onclick="setSimView('intersection')">
              <input type="radio" name="sim-view" value="intersection" style="accent-color:var(--accent);width:16px;height:16px">
              <div>
                <div style="font-weight:500;font-size:0.85rem;margin-bottom:2px">ğŸš¦ Intersection (Default)</div>
                <div style="font-size:0.72rem;color:var(--muted)">4-way intersection with EW and NS roads. Both axes active.</div>
              </div>
            </label>
            <label style="display:flex; align-items:center; gap:12px; cursor:pointer; padding:12px 14px; background:var(--surface2); border:2px solid var(--border); border-radius:8px; transition:border-color 0.2s" id="view-opt-horizontal" onclick="setSimView('horizontal')">
              <input type="radio" name="sim-view" value="horizontal" style="accent-color:var(--accent);width:16px;height:16px">
              <div>
                <div style="font-weight:500;font-size:0.85rem;margin-bottom:2px">â†” Horizontal Road Only</div>
                <div style="font-size:0.72rem;color:var(--muted)">Single horizontal road with crosswalk. East/West traffic only.</div>
              </div>
            </label>
            <label style="display:flex; align-items:center; gap:12px; cursor:pointer; padding:12px 14px; background:var(--surface2); border:2px solid var(--border); border-radius:8px; transition:border-color 0.2s" id="view-opt-vertical" onclick="setSimView('vertical')">
              <input type="radio" name="sim-view" value="vertical" style="accent-color:var(--accent);width:16px;height:16px">
              <div>
                <div style="font-weight:500;font-size:0.85rem;margin-bottom:2px">â†• Vertical Road Only</div>
                <div style="font-size:0.72rem;color:var(--muted)">Single vertical road with crosswalk. North/South traffic only.</div>
              </div>
            </label>
            <label style="display:flex; align-items:center; gap:12px; cursor:pointer; padding:12px 14px; background:var(--surface2); border:2px solid var(--border); border-radius:8px; transition:border-color 0.2s" id="view-opt-sideon" onclick="setSimView('sideon')">
              <input type="radio" name="sim-view" value="sideon" checked style="accent-color:var(--accent);width:16px;height:16px">
              <div>
                <div style="font-weight:500;font-size:0.85rem;margin-bottom:2px">ğŸ™ Side-On Street View</div>
                <div style="font-size:0.72rem;color:var(--muted)">View from the pavement â€” cars pass left to right, pedestrian waits at kerb.</div>
              </div>
            </label>
          </div>
          <div style="font-size:0.72rem;color:var(--muted);margin-top:4px">Changes take effect immediately. Simulation will restart with the new view.</div>
        </div>
      </div>
    </div>

    <!-- SNOWFLAKE DB -->
    <div class="admin-panel" id="panel-snowflake">
      <div class="admin-h1">Snowflake Integration</div>
      <div class="admin-sub">Connect Hen-Tersection to your Snowflake data warehouse for persistent event logging</div>

      <div class="settings-group">
        <div class="settings-group-title">SQL Schema (copy into Snowflake)</div>
        <pre style="background:var(--surface2);border:1px solid var(--border);border-radius:6px;padding:14px;font-family:var(--font-mono);font-size:0.72rem;color:#a8d8a8;overflow-x:auto;line-height:1.6">-- 1. Tell Snowflake WHERE to work
USE WAREHOUSE CROSSWALK_WH;
USE DATABASE SMART_CITY;
USE SCHEMA TRAFFIC_LOGS;

-- 2. Create the tables
CREATE OR REPLACE TABLE CROSSING_LOGS (
  event_id         STRING  DEFAULT uuid_string(),
  timestamp        TIMESTAMP_NTZ DEFAULT current_timestamp(),
  pedestrian_type  STRING,
  duration_seconds FLOAT,
  was_light_extended BOOLEAN
);

CREATE OR REPLACE TABLE JAYWALKING_VIOLATIONS (
  violation_id  STRING DEFAULT uuid_string(),
  timestamp     TIMESTAMP_NTZ DEFAULT current_timestamp(),
  severity      STRING,
  description   TEXT
);</pre>
      </div>

      <div class="settings-group">
        <div class="settings-group-title">Query: Recent Integration Tests</div>
        <pre style="background:var(--surface2);border:1px solid var(--border);border-radius:6px;padding:14px;font-family:var(--font-mono);font-size:0.72rem;color:#9ec5fe;overflow-x:auto;line-height:1.6">SELECT timestamp, severity, description
FROM SMART_CITY.TRAFFIC_LOGS.JAYWALKING_VIOLATIONS
WHERE description LIKE 'INTEGRATION_TEST%'
ORDER BY timestamp DESC
LIMIT 5;</pre>
      </div>

      <div class="settings-group">
        <div class="settings-group-title">Connection Settings</div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Snowflake Account</div>
            <div class="setting-label-desc">e.g. xy12345.us-east-1 (requires backend proxy for CORS)</div>
          </div>
          <input type="text" id="sf-account" placeholder="account.region" style="background:var(--surface2);border:1px solid var(--border);border-radius:5px;padding:7px 10px;color:var(--text);font-family:var(--font-mono);font-size:0.75rem;width:200px;outline:none">
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <div class="setting-label-text">Enable Real Logging</div>
            <div class="setting-label-desc">Send events to Snowflake (requires /api/snowflake proxy)</div>
          </div>
          <div class="toggle" id="t-sf-enabled" onclick="toggleSetting(this); SNOWFLAKE_CONFIG.enabled=this.classList.contains('on')">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div style="display:flex;gap:10px;align-items:center;margin-top:8px;flex-wrap:wrap">
          <button class="btn primary" onclick="saveSFConfig()">ğŸ’¾ Save Config</button>
          <button class="btn" id="sf-test-btn" onclick="testSFConnection()">ğŸ”Œ Test Connection</button>
          <span id="sf-status" style="font-size:0.75rem;color:var(--muted)">Not configured</span>
        </div>
      </div>

      <div class="settings-group" style="margin-top:16px">
        <div class="settings-group-title">Event Log Buffer <span style="font-weight:400;color:var(--muted);font-size:0.7rem">(local preview of what gets sent)</span></div>
        <div id="sf-event-list" style="max-height:260px;overflow-y:auto;padding:4px 0">
          <div style="color:var(--muted);font-size:0.72rem;text-align:center;padding:20px">No events yet</div>
        </div>
      </div>
    </div>

  </div><!-- /admin-content -->
</div>

<!-- Announcement toast -->
<div id="announcement-toast">
  <span class="toast-icon">ğŸ”Š</span>
  <span id="toast-text">Walk signal is on.</span>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let model = null;
let stream = null;
let animId = null;
let running = false;
let lastFpsTime = 0;
let frameCount = 0;

let crossingPhase = 'ew-green'; // ew-green | ew-yellow | ns-green | ns-yellow | pedestrian-walk | pedestrian-warn
let phaseTimer = 0;
let phaseMax = 45;
let countdownTimer = null;
let crossingTime = 20;
let mobilityDetected = false;
let warnTriggered = false;
let lastSpeech = '';

// Front-on crosswalk view column boundaries (fraction of frame width)
// Wider crosswalk, narrower wait zones
const CW_LEFT_FRAC  = 0.25; // left kerb edge (was 0.33)
const CW_RIGHT_FRAC = 0.75; // right kerb edge (was 0.67)

// Stats
let statCrossed = 0, statJay = 0, statMobility = 0;
let crossTimes = [];
let eventLog = [];

// â”€â”€â”€ PAGE SWITCHING â”€â”€â”€
function switchPage(id, el) {
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
  document.getElementById('page-' + id).classList.add('active');
  el.classList.add('active');
}

function switchAdminPanel(id, el) {
  document.querySelectorAll('.admin-panel').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.admin-nav-item').forEach(i => i.classList.remove('active'));
  document.getElementById('panel-' + id).classList.add('active');
  el.classList.add('active');
}

// â”€â”€â”€ CLOCK â”€â”€â”€
setInterval(() => {
  const n = new Date();
  document.getElementById('time-badge').textContent =
    [n.getHours(),n.getMinutes(),n.getSeconds()].map(v=>String(v).padStart(2,'0')).join(':');
}, 1000);

// â”€â”€â”€ SETTINGS HELPERS â”€â”€â”€
function updateRange(id, valId, suffix, fn) {
  const v = document.getElementById(id).value;
  document.getElementById(valId).textContent = fn(v) + suffix;
}
function toggleSetting(el) {
  el.classList.toggle('on');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRAFFIC LIGHT + PHASE ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PHASES = {
  'ew-green':       { duration: () => getSettingVal('r-green-phase', 45), next: 'ew-yellow' },
  'ew-yellow':      { duration: () => getSettingVal('r-yellow-phase', 4), next: 'pedestrian-walk' },
  'ns-green':       { duration: () => getSettingVal('r-green-phase', 45), next: 'ns-yellow' },
  'ns-yellow':      { duration: () => getSettingVal('r-yellow-phase', 4), next: 'pedestrian-walk' },
  'pedestrian-walk':{ duration: () => getCrossingTime(), next: 'pedestrian-warn' },
  'pedestrian-warn':{ duration: () => getSettingVal('r-warn-start', 7), next: 'ew-green' },
};

function getSettingVal(id, def) {
  const el = document.getElementById(id);
  return el ? parseInt(el.value) : def;
}

function getCrossingTime() {
  let t = getSettingVal('r-default-time', 20);
  if (mobilityDetected && isToggleOn('t-slow-extend')) {
    t += getSettingVal('r-mobility-ext', 15);
  }
  return t;
}

function isToggleOn(id) {
  const el = document.getElementById(id);
  return el ? el.classList.contains('on') : true;
}

function setPhase(phase) {
  crossingPhase = phase;
  phaseMax = PHASES[phase].duration();
  phaseTimer = phaseMax;
  warnTriggered = false;
  // Reset per-cycle flags
  if (phase === 'ew-green' || phase === 'ns-green') {
    window._greenReducedThisCycle = false;
    window._greenExtendedThisCycle = false;
    window._emptyZoneSince = null;
    window._warnExtended = false;
    window._slowCrosserExtendedAt = null;
    window._slowCrosserFlagged = false;
    window._authoritiesAlerted = false;
    // Note: _triagePending/_triageDispatched/_triagePedId/_triageBbox are NOT reset here
    // They are consumed by onPhaseStart('ew-green'/'ns-green') below, then cleared in a timeout
  }
  if (phase === 'pedestrian-walk') {
    // Only reset the extension guard if this is NOT being triggered by our own extension code
    // We detect that by checking _warnExtended â€” if it's already true, this is the extension itself
    if (!window._warnExtended) {
      window._slowCrosserExtendedAt = null;
      window._slowCrosserFlagged = false;
    }
    window._pedClearedAt = null;
  }

  updateLights();
  updatePhaseUI();
  onPhaseStart(phase);

  clearInterval(countdownTimer);
  countdownTimer = setInterval(() => tickPhase(), 1000);
}

function tickPhase() {
  phaseTimer--;
  updateTimerUI();

  if (phaseTimer <= 0) {
    clearInterval(countdownTimer);
    // If this yellow was triggered by a jaywalker and all jaywalkers have left â†’ revert to green
    if (window._jaywalkerYellow &&
        (crossingPhase === 'ew-yellow' || crossingPhase === 'ns-yellow') &&
        !trackedPedestrians.some(p => p.loggedJay && !p.capturedPhoto && p.seenThisFrame)) {
      window._jaywalkerYellow = false;
      const revert = window._jaywalkerYellowRevertTo || 'ew-green';
      window._jaywalkerYellowRevertTo = null;
      showToast('âœ… Crosswalk clear â€” reverting to green', '#22c55e');
      setPhase(revert);
      phaseTimer = Math.max(8, Math.floor(getSettingVal('r-green-phase', 45) * 0.4));
      phaseMax = phaseTimer;
      updateTimerUI();
    } else {
      window._jaywalkerYellow = false;
      setPhase(PHASES[crossingPhase].next);
    }
  }
}

function updateLights() {
  const vGreen  = crossingPhase === 'ew-green' || crossingPhase === 'ns-green';
  const vYellow = crossingPhase === 'ew-yellow' || crossingPhase === 'ns-yellow';
  const vRed    = !vGreen && !vYellow;

  // Update all 4 vehicle light elements (2 on live monitor, 2 on sim sidebar)
  const lightIds = ['light-red','light-yellow','light-green'];
  lightIds.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    if (id.includes('red'))    el.classList.toggle('on', vRed);
    if (id.includes('yellow')) el.classList.toggle('on', vYellow);
    if (id.includes('green'))  el.classList.toggle('on', vGreen);
  });

  // Pedestrian walk icon
  const walkIcon = document.getElementById('walk-icon');
  if (!walkIcon) return;
  if (crossingPhase === 'pedestrian-walk') {
    walkIcon.textContent = 'ğŸš¶'; walkIcon.className = 'walk-icon walk';
  } else if (crossingPhase === 'pedestrian-warn') {
    walkIcon.textContent = 'ğŸš·'; walkIcon.className = 'walk-icon dont-walk';
  } else {
    // vehicle-green or yellow â†’ do not walk
    walkIcon.textContent = 'ğŸ›‘'; walkIcon.className = 'walk-icon dont-walk';
  }
}

function updateTimerUI() {
  const n = document.getElementById('countdown-num');
  const fill = document.getElementById('ring-fill');
  const bar = document.getElementById('time-bar-fill');
  const tv = document.getElementById('timer-val');

  n.textContent = phaseTimer;
  tv.textContent = phaseTimer + 's';

  const pct = phaseTimer / phaseMax;
  const circumference = 125.7;
  fill.setAttribute('stroke-dashoffset', circumference * (1 - pct));

  const barPct = pct * 100;
  bar.style.width = barPct + '%';

  let color;
  if (crossingPhase === 'pedestrian-walk') color = '#22c55e';
  else if (crossingPhase === 'pedestrian-warn') color = '#f59e0b';
  else color = '#ef4444';
  fill.setAttribute('stroke', color);
  bar.style.background = color;
}

function updatePhaseUI() {
  const labels = {
    'ew-green':        'EW Green',
    'ew-yellow':       'EW Yellow',
    'ns-green':        'NS Green',
    'ns-yellow':       'NS Yellow',
    'pedestrian-walk': 'Walk Signal',
    'pedestrian-warn': 'Warning Phase',
  };
  document.getElementById('phase-label').textContent = labels[crossingPhase] || crossingPhase;
}

function onPhaseStart(phase) {
  if (phase === 'pedestrian-walk') {
    if (mobilityDetected) {
      speak('mobility');
      showToast('ğŸ¦½ Mobility aid detected â€” Extended time: ' + getCrossingTime() + 's', '#3b82f6');
    } else {
      speak('walk');
      showToast('ğŸš¶ Walk signal active â€” ' + getCrossingTime() + 's', '#22c55e');
    }
    logEvent('walk', mobilityDetected);
    sfLogCrossing(mobilityDetected ? 'mobility' : 'normal', getCrossingTime(), mobilityDetected);
  } else if (phase === 'pedestrian-warn') {
    // Check immediately if anyone is still in the crosswalk â€” if so, skip warn and extend now
    const canvas2 = document.getElementById('canvas');
    const cw2 = canvas2 ? canvas2.width : 800;
    const warnCwZone = zoneShapes.find(z => z.type === 'crosswalk');
    const warnLeft  = warnCwZone ? warnCwZone.x * (cw2/800) : cw2 * CW_LEFT_FRAC;
    const warnRight = warnCwZone ? (warnCwZone.x+warnCwZone.w) * (cw2/800) : cw2 * CW_RIGHT_FRAC;
    const someoneStillCrossing = trackedPedestrians.some(p => p.seenThisFrame && p.cx >= warnLeft && p.cx <= warnRight);

    if (someoneStillCrossing && !window._warnExtended) {
      // First time warn fires with someone still inside â†’ grant one 8s extension
      window._warnExtended = true;
      window._slowCrosserExtendedAt = performance.now();
      window._slowCrosserFlagged = false;
      clearInterval(countdownTimer);
      crossingPhase = 'pedestrian-walk';
      phaseTimer = 8;
      phaseMax   = 8;
      updateTimerUI();
      updateLights();
      updatePhaseUI();
      countdownTimer = setInterval(() => tickPhase(), 1000);
      showToast('âš ï¸ Person still crossing â€” FINAL 8s extension', '#f59e0b');
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const utt = new SpeechSynthesisUtterance('Warning. You must finish crossing now. The signal will change in 8 seconds.');
        utt.rate = parseFloat(document.getElementById('r-speech-rate')?.value || 9) / 10;
        utt.volume = parseFloat(document.getElementById('r-vol')?.value || 9) / 10;
        window.speechSynthesis.speak(utt);
      }
      return;
    }

    // pedestrian-warn starting after completed extension â€” someone still crossing
    // Only store the ped reference here. Photo + flag + triage all fire when light goes green.
    if (window._warnExtended && someoneStillCrossing && !window._triagePending) {
      const refusePed = trackedPedestrians.find(p => p.seenThisFrame && p.cx >= warnLeft && p.cx <= warnRight);
      if (refusePed) {
        window._triagePending = true;
        window._triagePedRef = refusePed; // snapshot ref â€” used when green fires
        window._triageBbox   = [...refusePed.bbox];
        window._triagePedId  = refusePed.id;
        // Inform the pedestrian their situation is being assessed â€” calm, non-alarming
        if ('speechSynthesis' in window) {
          window.speechSynthesis.cancel();
          const rate = parseFloat(document.getElementById('r-speech-rate')?.value || 9) / 10;
          const vol  = parseFloat(document.getElementById('r-vol')?.value || 9) / 10;
          const msgs = [
            'This crossing event is being reviewed for your safety and wellbeing.',
            'This crossing event is being reviewed for your safety and wellbeing.',
            'This crossing event is being reviewed for your safety and wellbeing.'
          ];
          let mIdx = 0;
          function speakReview() {
            if (mIdx >= msgs.length) return;
            const utt = new SpeechSynthesisUtterance(msgs[mIdx++]);
            utt.rate = rate; utt.volume = vol;
            utt.onend = () => setTimeout(speakReview, 1500);
            window.speechSynthesis.speak(utt);
          }
          speakReview();
        }
      }
    }


    speak('warn');
    showToast('âš ï¸ Signal changing soon!', '#f59e0b');
  } else if (phase === 'ew-green' || phase === 'ns-green') {
    speak('stop');
    // Light just went green for vehicles = red for peds.
    // If a crosser refused to leave after the full warning, fire everything now.
    if (window._triagePending && !window._triageDispatched) {
      window._triageDispatched = true;
      const pedId = window._triagePedId != null ? window._triagePedId + 1 : '?';
      // Take photo using stored bbox
      if (window._triageBbox) {
        captureJaywalkerSnapshot(window._triageBbox, window._triagePedId || 0);
      }
      sfLogJaywalk('VIOLATION', `Non-compliant crosser #${pedId} â€” still in crosswalk when light turned green. Triage dispatched.`);
      addDetectionItem('ğŸ¢', 'Non-compliant crosser', 'Still crossing at red â€” flagged & triage dispatched', 'jay');
      logEvent('timeout', false);
      const triagePayload = {
        event: 'crosswalk_refusal',
        timestamp: new Date().toISOString(),
        pedestrian_id: pedId,
        location: document.getElementById('site-location')?.value || 'Hen-Tersection Unit',
        severity: 'HIGH',
        description: `Pedestrian #${pedId} remained in crosswalk after full extended warning and final red light. Video evidence captured.`,
        video_evidence: true,
      };
      fetch('/api/triage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(triagePayload)
      }).catch(() => {});
      addDetectionItem('ğŸš¨', 'Alert Dispatched', 'Triage notified â€” help is on the way', 'jay');
      showToast('ğŸš¨ Triage alert dispatched â€” help en route', '#ef4444');
      // Reassure the pedestrian
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const rate = parseFloat(document.getElementById('r-speech-rate')?.value || 9) / 10;
        const vol  = parseFloat(document.getElementById('r-vol')?.value || 9) / 10;
        const msgs = [
          'Help is on the way. Someone will be with you shortly.',
          'Help is on the way. Someone will be with you shortly.',
          'Help is on the way. Someone will be with you shortly.'
        ];
        let mIdx2 = 0;
        function speakHelp() {
          if (mIdx2 >= msgs.length) return;
          const utt = new SpeechSynthesisUtterance(msgs[mIdx2++]);
          utt.rate = rate; utt.volume = vol;
          utt.onend = () => setTimeout(speakHelp, 1500);
          window.speechSynthesis.speak(utt);
        }
        speakHelp();
      }
    }
  }
  // Fire sim hook if available
  if (typeof simPhaseHook === 'function') simPhaseHook(phase);
}

function triggerCrossNow() {
  clearInterval(countdownTimer);
  if (crossingPhase === 'pedestrian-walk' || crossingPhase === 'pedestrian-warn') {
    // Already in pedestrian phase â€” nothing to do
    showToast('ğŸš¶ Walk signal already active', '#f5a623');
    return;
  }
  // Always transition through yellow first (1s), then to pedestrian-walk
  // This prevents cars from teleporting mid-intersection
  const needsYellow = crossingPhase === 'ew-green' || crossingPhase === 'ns-green';
  if (needsYellow) {
    const yellowPhase = crossingPhase === 'ew-green' ? 'ew-yellow' : 'ns-yellow';
    setPhase(yellowPhase);
    // Override yellow timer to be brief (2s) for the manual trigger
    phaseTimer = 2;
    phaseMax = 2;
    updateTimerUI();
    showToast('ğŸ– Manual crossing â€” clearing trafficâ€¦', '#f5a623');
  } else {
    setPhase('pedestrian-walk');
    showToast('ğŸ– Manual crossing triggered', '#f5a623');
  }
}

setPhase('ew-green');

// â”€â”€â”€ SNOWFLAKE INTEGRATION â”€â”€â”€
// Simulates Snowflake DB logging with SQL-compatible schema
// In production, replace fetch calls with your Snowflake REST endpoint or backend proxy
const SNOWFLAKE_CONFIG = {
  account: '', // e.g. 'xy12345.us-east-1'
  warehouse: 'CROSSWALK_WH',
  database: 'SMART_CITY',
  schema: 'TRAFFIC_LOGS',
  enabled: false, // set to true and provide account/token to enable real logging
};

// Local buffer of pending Snowflake events (shown in DB panel)
let sfEventBuffer = [];
let sfConnected = false;

function sfLog(table, data) {
  const ts = new Date().toISOString();
  const record = { table, ts, data, status: SNOWFLAKE_CONFIG.enabled ? 'sending' : 'buffered' };
  sfEventBuffer.unshift(record);
  if (sfEventBuffer.length > 100) sfEventBuffer.pop();
  renderSFLog();

  if (!SNOWFLAKE_CONFIG.enabled) return;

  // Real Snowflake REST API call (requires backend proxy due to CORS)
  // Replace '/api/snowflake' with your proxy endpoint
  fetch('/api/snowflake', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      warehouse: SNOWFLAKE_CONFIG.warehouse,
      database: SNOWFLAKE_CONFIG.database,
      schema: SNOWFLAKE_CONFIG.schema,
      table,
      record: { ...data, timestamp: ts }
    })
  }).then(r => {
    record.status = r.ok ? 'sent' : 'error';
    renderSFLog();
  }).catch(() => {
    record.status = 'error';
    renderSFLog();
  });
}

function sfLogCrossing(pedType, durationSeconds, wasExtended) {
  sfLog('CROSSING_LOGS', {
    pedestrian_type: pedType,
    duration_seconds: durationSeconds,
    was_light_extended: wasExtended,
  });
}

function sfLogJaywalk(severity, description) {
  sfLog('JAYWALKING_VIOLATIONS', {
    severity,
    description,
  });
}

function renderSFLog() {
  const el = document.getElementById('sf-event-list');
  if (!el) return;
  if (!sfEventBuffer.length) {
    el.innerHTML = '<div style="color:var(--muted);font-size:0.72rem;text-align:center;padding:20px">No events yet</div>';
    return;
  }
  const statusColors = { sent: 'var(--go)', buffered: 'var(--muted)', sending: 'var(--warn)', error: 'var(--stop)' };
  el.innerHTML = sfEventBuffer.slice(0, 50).map(e => {
    const col = statusColors[e.status] || 'var(--muted)';
    const timeStr = e.ts.split('T')[1].split('.')[0];
    const dataStr = Object.entries(e.data).map(([k,v]) => `${k}=${JSON.stringify(v)}`).join(', ');
    return `<div class="sim-evt" style="border-left:2px solid ${col};padding-left:6px;margin-bottom:3px">
      <span class="sim-evt-time">${timeStr}</span>
      <div style="flex:1;min-width:0">
        <div style="color:${col};font-size:0.65rem">${e.table} Â· ${e.status.toUpperCase()}</div>
        <div style="font-size:0.62rem;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${dataStr}</div>
      </div>
    </div>`;
  }).join('');
}

function testSFConnection() {
  const btn = document.getElementById('sf-test-btn');
  const status = document.getElementById('sf-status');
  if (btn) btn.textContent = 'Testingâ€¦';
  sfLog('JAYWALKING_VIOLATIONS', { severity: 'INFO', description: 'INTEGRATION_TEST: Connection check from Hen-Tersection v7' });
  setTimeout(() => {
    if (btn) btn.textContent = 'ğŸ”Œ Test Connection';
    if (status) {
      status.textContent = SNOWFLAKE_CONFIG.enabled ? 'âœ“ Event sent to Snowflake' : 'âš  Buffered (enable real endpoint in config)';
      status.style.color = SNOWFLAKE_CONFIG.enabled ? 'var(--go)' : 'var(--warn)';
    }
  }, 800);
}

function saveSFConfig() {
  const acct = document.getElementById('sf-account')?.value?.trim();
  if (acct) {
    SNOWFLAKE_CONFIG.account = acct;
    SNOWFLAKE_CONFIG.enabled = true;
    sfConnected = true;
    document.getElementById('sf-status').textContent = `âœ“ Config saved â€” account: ${acct}`;
    document.getElementById('sf-status').style.color = 'var(--go)';
  }
  showToast('ğŸ’¾ Snowflake config updated', '#3b82f6');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function loadModel() {
  try {
    document.getElementById('model-badge').textContent = 'â— Loadingâ€¦';
    model = await cocoSsd.load();
    document.getElementById('model-badge').textContent = 'â— Model Ready';
    document.getElementById('model-badge').classList.add('green');
    document.getElementById('start-btn').disabled = false;
  } catch(e) {
    document.getElementById('model-badge').textContent = 'â— Model Error';
    console.error(e);
  }
}

async function enumerateCameras() {
  const sel = document.getElementById('camera-select');
  const prevVal = sel.value;
  try {
    // Need at least a temporary permission grant to get device labels
    const tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    tmp.getTracks().forEach(t => t.stop());
  } catch(e) { /* permission denied â€” labels may be blank */ }

  const devices = await navigator.mediaDevices.enumerateDevices();
  const cameras = devices.filter(d => d.kind === 'videoinput');

  sel.innerHTML = '<option value="">ğŸ“· Default Camera</option>';
  cameras.forEach((cam, i) => {
    const opt = document.createElement('option');
    opt.value = cam.deviceId;
    opt.textContent = cam.label || `Camera ${i + 1}`;
    // Highlight likely iPhone/external cameras
    if (/iphone|continuity|epoccam|droidcam|ivcam|nddi/i.test(cam.label)) {
      opt.textContent = 'ğŸ“± ' + opt.textContent;
    } else if (i > 0) {
      opt.textContent = 'ğŸ¥ ' + opt.textContent;
    }
    sel.appendChild(opt);
  });

  // Restore previous selection if still available
  if ([...sel.options].some(o => o.value === prevVal)) sel.value = prevVal;

  showToast(`ğŸ“· Found ${cameras.length} camera${cameras.length !== 1 ? 's' : ''}`, '#3b82f6');
}

async function startCamera() {
  try {
    const deviceId = document.getElementById('camera-select').value;
    const videoConstraints = deviceId
      ? { deviceId: { exact: deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } }
      : { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'environment' };

    stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: false });
    const video = document.getElementById('video');
    video.srcObject = stream;
    await video.play();
    running = true;
    document.getElementById('start-btn').disabled = true;
    document.getElementById('stop-btn').disabled = false;
    document.getElementById('camera-select').disabled = true;
    document.getElementById('refresh-cams-btn').disabled = true;

    // Show active camera name in the overlay
    const track = stream.getVideoTracks()[0];
    const label = track.label || 'Camera';
    document.getElementById('cam-info').textContent = `SMARTCROSS // ${label.toUpperCase().substring(0, 40)}`;

    // Refresh the dropdown list with real labels now we have permission
    enumerateCameras().then(() => {
      if (deviceId) document.getElementById('camera-select').value = deviceId;
      document.getElementById('camera-select').disabled = true;
    });

    detect();
  } catch(e) {
    showToast('âŒ Camera access denied or device not found', '#ef4444');
    console.error(e);
  }
}

function stopCamera() {
  running = false;
  if (animId) cancelAnimationFrame(animId);
  if (stream) stream.getTracks().forEach(t => t.stop());
  const canvas = document.getElementById('canvas');
  canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
  document.getElementById('start-btn').disabled = false;
  document.getElementById('stop-btn').disabled = true;
  document.getElementById('camera-select').disabled = false;
  document.getElementById('refresh-cams-btn').disabled = false;
  document.getElementById('cam-info').textContent = 'CAMERA STOPPED';
}

let lastDetectionLog = 0;
let lastMobilityCheck = 0;
let prevPersonCount = 0;
// â”€â”€ IMPROVED PEDESTRIAN TRACKER (IoU + centroid matching) â”€â”€
// Tracks unique pedestrians across frames using bounding-box overlap to prevent duplication
let trackedPedestrians = []; // [{id, bbox:[x,y,w,h], cx, cy, lastSeen, loggedNormal, loggedJay, jayStartTime, conf, seenThisFrame}]
let pedIdCounter = 0;
const PED_IOU_THRESHOLD = 0.25;  // minimum IoU to match same person
const PED_CENTROID_DIST = 100;   // fallback: max centroid distance for match (px)
const PED_EXPIRY_MS     = 2500;  // remove track if unseen for this long
const JAY_VIOLATION_SEC = 3;     // seconds in crosswalk on red before RED-light trigger

function iouBBox(a, b) {
  // a, b are [x, y, w, h]
  const ax2 = a[0]+a[2], ay2 = a[1]+a[3];
  const bx2 = b[0]+b[2], by2 = b[1]+b[3];
  const ix1 = Math.max(a[0], b[0]), iy1 = Math.max(a[1], b[1]);
  const ix2 = Math.min(ax2, bx2),   iy2 = Math.min(ay2, by2);
  if (ix2 <= ix1 || iy2 <= iy1) return 0;
  const inter = (ix2-ix1)*(iy2-iy1);
  const unionA = a[2]*a[3], unionB = b[2]*b[3];
  return inter / (unionA + unionB - inter);
}

function matchPedestrian(pred) {
  const [bx, by, bw, bh] = pred.bbox;
  const pcx = bx + bw/2, pcy = by + bh/2;
  let best = null, bestScore = -1;
  trackedPedestrians.forEach(t => {
    const iou = iouBBox(pred.bbox, t.bbox);
    const dist = Math.hypot(t.cx - pcx, t.cy - pcy);
    // Combined score: prefer IoU, fallback to distance
    const score = iou > PED_IOU_THRESHOLD ? iou + 1 : (dist < PED_CENTROID_DIST ? (PED_CENTROID_DIST - dist) / PED_CENTROID_DIST : -1);
    if (score > bestScore) { bestScore = score; best = t; }
  });
  return bestScore > 0 ? best : null;
}

async function detect() {
  if (!running) return;

  try {
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

  frameCount++;
  const now = performance.now();
  if (now - lastFpsTime > 1000) {
    document.getElementById('cam-fps').textContent = frameCount + ' FPS';
    frameCount = 0;
    lastFpsTime = now;
  }

  if (video.readyState === 4) {
    // Only resize canvas when dimensions actually change â€” resizing clears context every frame
    if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    let predictions = [];
    try {
      predictions = await model.detect(video);
    } catch(e) {
      // Model error (e.g. GPU stall with multiple people) â€” skip frame, keep loop alive
      console.warn('Detection error (skipping frame):', e);
      animId = requestAnimationFrame(detect);
      return;
    }

    const persons = predictions.filter(p => p.class === 'person' &&
      p.score * 100 >= getSettingVal('r-person-thresh', 55));

    // Mobility detection
    const mobilityObjs = predictions.filter(p =>
      ['umbrella', 'handbag', 'backpack', 'suitcase'].includes(p.class) && p.score > 0.55);
    const hasMobility = mobilityObjs.length > 0 && persons.length > 0;
    if (hasMobility && now - lastMobilityCheck > 8000) {
      mobilityDetected = true;
      lastMobilityCheck = now;
      setTimeout(() => { mobilityDetected = false; }, 20000);
      addDetectionItem('ğŸ¦½', 'Mobility Aid', 'Cane / Wheelchair detected', 'mobility');
      statMobility++;
      document.getElementById('stat-mobility').textContent = statMobility;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw column guides
    const cwColL = canvas.width * CW_LEFT_FRAC;
    const cwColR = canvas.width * CW_RIGHT_FRAC;
    ctx.save();
    ctx.fillStyle = 'rgba(34,197,94,0.04)';
    ctx.fillRect(cwColL, 0, cwColR - cwColL, canvas.height);
    ctx.strokeStyle = 'rgba(59,130,246,0.4)';
    ctx.lineWidth = 1.5; ctx.setLineDash([10, 7]);
    ctx.beginPath(); ctx.moveTo(cwColL, 0); ctx.lineTo(cwColL, canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cwColR, 0); ctx.lineTo(cwColR, canvas.height); ctx.stroke();
    ctx.setLineDash([]);
    // Draw text un-mirrored: flip context at canvas center, draw at mirrored x
    ctx.font = '10px DM Mono, monospace';
    ctx.textAlign = 'center';
    ctx.translate(canvas.width, 0);
    ctx.scale(-1, 1);
    // Mirror x: newX = canvas.width - originalX
    const mL = canvas.width - cwColL / 2;
    const mC = canvas.width - (cwColL + (cwColR - cwColL) / 2);
    const mR = canvas.width - (cwColR + (canvas.width - cwColR) / 2);
    ctx.fillStyle = 'rgba(59,130,246,0.55)';
    ctx.fillText('WAIT', mL, 14);
    ctx.fillStyle = 'rgba(34,197,94,0.55)';
    ctx.fillText('CROSSWALK', mC, 14);
    ctx.fillStyle = 'rgba(59,130,246,0.55)';
    ctx.fillText('WAIT', mR, 14);
    ctx.restore();

    drawZoneOverlay(ctx, canvas.width, canvas.height);

    // Draw bounding boxes
    persons.forEach((pred, i) => {
      const [x,y,w,h] = pred.bbox;
      const conf = Math.round(pred.score * 100);
      const isMobility = mobilityDetected && i === 0;
      const personCenterX = x + w / 2;
      const isInCrosswalk = personCenterX >= cwColL && personCenterX <= cwColR;
      const isVehicleGreenNow = crossingPhase === 'ew-green' || crossingPhase === 'ns-green';
      const isJay = isVehicleGreenNow && isInCrosswalk;
      const color = isJay ? '#ef4444' : isMobility ? '#3b82f6' : '#22c55e';

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;
      ctx.strokeRect(x, y, w, h);
      ctx.shadowBlur = 0;

      const cs = 14;
      ctx.lineWidth = 3;
      [[x,y],[x+w,y],[x,y+h],[x+w,y+h]].forEach(([bx,by], ci) => {
        const sx = ci%2===0?1:-1, sy = ci<2?1:-1;
        ctx.beginPath();
        ctx.moveTo(bx+sx*cs, by);
        ctx.lineTo(bx, by);
        ctx.lineTo(bx, by+sy*cs);
        ctx.stroke();
      });

      const label = isJay ? `âš  JAYWALKER` : isMobility ? `ğŸ¦½ MOBILITY` : `PERSON ${i+1}`;
      // Draw label un-mirrored (canvas is CSS-flipped, so flip ctx before text)
      const labelW = 160, labelH = 22;
      const labelX = canvas.width - x - labelW; // mirror x for flipped canvas
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.fillRect(labelX, y-labelH, labelW, labelH);
      ctx.save();
      ctx.translate(canvas.width, 0);
      ctx.scale(-1, 1);
      ctx.fillStyle = color;
      ctx.font = '11px "DM Mono", monospace';
      ctx.textAlign = 'left';
      ctx.fillText(`${label}  ${conf}%`, labelX + 6, y - 6);
      ctx.restore();
      ctx.restore();
    });

    // â”€â”€ PEDESTRIAN TRACKER (IoU-based) â”€â”€
    const nowMs = now;
    trackedPedestrians.forEach(t => t.seenThisFrame = false);

    persons.forEach((pred) => {
      const [bx, by, bw2, bh2] = pred.bbox;
      const pcx = bx + bw2/2, pcy = by + bh2/2;
      const existing = matchPedestrian(pred);
      if (existing) {
        existing.bbox = [bx, by, bw2, bh2];
        existing.cx = pcx; existing.cy = pcy;
        existing.lastSeen = nowMs;
        existing.seenThisFrame = true;
        existing.conf = pred.score;
      } else {
        const ped = {
          id: pedIdCounter++, bbox: [bx, by, bw2, bh2],
          cx: pcx, cy: pcy,
          lastSeen: nowMs, seenThisFrame: true, conf: pred.score,
          loggedNormal: false, loggedJay: false, capturedPhoto: false,
          jayStartTime: null,
        };
        trackedPedestrians.push(ped);
        const type = mobilityDetected ? 'mobility' : 'normal';
        addDetectionItem(mobilityDetected?'ğŸ¦½':'ğŸš¶', `Pedestrian #${ped.id+1}`,
          `Conf: ${Math.round(pred.score*100)}%`, type);
      }
    });

    trackedPedestrians = trackedPedestrians.filter(t => nowMs - t.lastSeen < PED_EXPIRY_MS);

    // â”€â”€ SMART SIGNAL LOGIC â”€â”€
    const cwZoneS = zoneShapes.find(z => z.type === 'crosswalk');
    const smLeft  = cwZoneS ? cwZoneS.x * (canvas.width/800) : cwColL;
    const smRight = cwZoneS ? (cwZoneS.x+cwZoneS.w) * (canvas.width/800) : cwColR;

    const anyoneInCrosswalk = trackedPedestrians.some(p => p.seenThisFrame && p.cx >= smLeft && p.cx <= smRight);
    const anyoneWaiting     = trackedPedestrians.some(p => p.seenThisFrame && (p.cx < smLeft || p.cx > smRight));
    const isVehicleGreenNow2 = crossingPhase === 'ew-green' || crossingPhase === 'ns-green';

    // EXTEND GREEN â€” no one waiting, but only after 1.5s of consistently empty frames (debounce)
    if (isVehicleGreenNow2) {
      if (!anyoneWaiting && persons.length === 0) {
        // Start or continue the empty-zone timer
        if (!window._emptyZoneSince) window._emptyZoneSince = nowMs;
        const emptyMs = nowMs - window._emptyZoneSince;
        if (!window._greenExtendedThisCycle && phaseTimer <= 8 && phaseTimer > 0 && emptyMs >= 1500) {
          window._greenExtendedThisCycle = true;
          const ext = Math.min(getSettingVal('r-green-phase', 45), phaseTimer + 15);
          phaseTimer = ext;
          phaseMax = Math.max(phaseMax, ext);
          updateTimerUI();
          showToast('ğŸŸ¢ No pedestrians waiting â€” green extended', '#22c55e');
        }
      } else {
        // Someone is present â€” reset the empty timer so it has to start over
        window._emptyZoneSince = null;
        if (anyoneWaiting) window._greenExtendedThisCycle = false;
      }
    } else {
      window._emptyZoneSince = null;
    }

    // 2. PEDESTRIAN CLEARED â€” cut walk phase early (with 3s grace)
    if (crossingPhase === 'pedestrian-walk' && phaseTimer > 4) {
      if (!anyoneInCrosswalk && persons.length === 0) {
        if (!window._pedClearedAt) {
          window._pedClearedAt = nowMs;
        } else if (nowMs - window._pedClearedAt > 3000) {
          window._pedClearedAt = null;
          showToast('âœ… Crosswalk clear â€” ending walk phase early', '#22c55e');
          clearInterval(countdownTimer);
          setPhase('pedestrian-warn');
        }
      } else {
        window._pedClearedAt = null;
      }
    }

    // 3. // Non-compliant crosser is flagged in onPhaseStart('pedestrian-warn') after extension, when light goes red

    // Reset pedClearedAt when we're not in walk phase
    if (crossingPhase !== 'pedestrian-walk') window._pedClearedAt = null;

    // â”€â”€ JAYWALKER CHECK â”€â”€
    const isVehicleGreen = crossingPhase === 'ew-green' || crossingPhase === 'ns-green';
    const isVehicleYellow = crossingPhase === 'ew-yellow' || crossingPhase === 'ns-yellow';
    if ((isVehicleGreen || isVehicleYellow) && isToggleOn('t-jay-log')) {
      const cwZone = zoneShapes.find(z => z.type === 'crosswalk');
      const jayLeft  = cwZone ? cwZone.x * (canvas.width/800) : cwColL;
      const jayRight = cwZone ? (cwZone.x+cwZone.w) * (canvas.width/800) : cwColR;

      trackedPedestrians.forEach(ped => {
        if (!ped.seenThisFrame) { ped.jayStartTime = null; return; }
        const inCrosswalk = ped.cx >= jayLeft && ped.cx <= jayRight;
        if (!inCrosswalk) { ped.jayStartTime = null; return; }

        // In crosswalk during green â†’ immediately yellow
        if (!ped.loggedJay && (crossingPhase === 'ew-green' || crossingPhase === 'ns-green')) {
          ped.loggedJay = true;
          ped.jayPhase = crossingPhase; // save BEFORE setPhase changes it
          statJay++;
          document.getElementById('stat-jay').textContent = statJay;
          addDetectionItem('âš ï¸', 'Jaywalker', 'In crosswalk â€” YELLOW triggered', 'jay');
          logEvent('jaywalk', false);
          sfLogJaywalk('WARNING', `Jaywalker detected â€” auto yellow triggered`);
          showToast('âš ï¸ Jaywalker detected â€” yellow light triggered!', '#f59e0b');
          const nextYellow = ped.jayPhase === 'ew-green' ? 'ew-yellow' : 'ns-yellow';
          window._jaywalkerYellow = true;
          window._jaywalkerYellowRevertTo = ped.jayPhase;
          clearInterval(countdownTimer);
          setPhase(nextYellow);
          ped.jayStartTime = nowMs;
        }

        // Start dwell timer once in yellow
        if (ped.jayStartTime === null && (crossingPhase === 'ew-yellow' || crossingPhase === 'ns-yellow')) {
          ped.jayStartTime = nowMs;
        }

        // 3s dwell â†’ force pedestrian-walk + snapshot
        if (ped.jayStartTime !== null && !ped.capturedPhoto) {
          const dwellSec = (nowMs - ped.jayStartTime) / 1000;
          if (dwellSec >= JAY_VIOLATION_SEC) {
            ped.capturedPhoto = true;
            captureJaywalkerSnapshot(ped.bbox, ped.id);
            sfLogJaywalk('VIOLATION', `Jaywalker #${ped.id+1} â€” ${JAY_VIOLATION_SEC}s violation â€” photo captured`);
            showToast('ğŸ“¸ 3s violation â€” photo captured, forcing red!', '#ef4444');
            clearInterval(countdownTimer);
            setPhase('pedestrian-walk');
          }
        }
      });

      // Jaywalker LEFT crosswalk before 3s â†’ revert yellow back to green immediately
      if (window._jaywalkerYellow && (crossingPhase === 'ew-yellow' || crossingPhase === 'ns-yellow')) {
        const anyJayStillIn = trackedPedestrians.some(p =>
          p.loggedJay && !p.capturedPhoto && p.seenThisFrame &&
          p.cx >= jayLeft && p.cx <= jayRight
        );
        if (!anyJayStillIn) {
          // Check none have hit the 3s threshold either
          const anyViolation = trackedPedestrians.some(p => {
            if (!p.loggedJay || p.capturedPhoto || p.jayStartTime === null) return false;
            return (nowMs - p.jayStartTime) / 1000 >= JAY_VIOLATION_SEC;
          });
          if (!anyViolation) {
            window._jaywalkerYellow = false;
            const revert = window._jaywalkerYellowRevertTo || 'ew-green';
            window._jaywalkerYellowRevertTo = null;
            trackedPedestrians.forEach(p => { if (p.loggedJay && !p.capturedPhoto) { p.jayStartTime = null; p.loggedJay = false; } });
            showToast('âœ… Jaywalker cleared â€” reverting to green', '#22c55e');
            clearInterval(countdownTimer);
            setPhase(revert);
            phaseTimer = Math.max(8, Math.floor(getSettingVal('r-green-phase', 45) * 0.4));
            phaseMax = phaseTimer;
            updateTimerUI();
          }
        }
      }
    }

    // â”€â”€ PEDESTRIAN WAITING VISUAL CUE â”€â”€
    updatePedWaitingCue(trackedPedestrians.length, isVehicleGreen);

    updateVoiceBars(persons.length > 0);
  } // end if (video.readyState === 4)

  } catch(e) {
    console.warn('detect() error (frame skipped):', e);
  }

  animId = requestAnimationFrame(detect);
}

function updatePedWaitingCue(pedCount, isVehicleGreen) {
  let cueEl = document.getElementById('ped-waiting-cue');
  if (!cueEl) return;
  if (!isVehicleGreen) { cueEl.style.display = 'none'; return; }

  const cw = document.getElementById('canvas');
  const canvasW = cw ? cw.width : 1280;
  const cwL = canvasW * CW_LEFT_FRAC;
  const cwR = canvasW * CW_RIGHT_FRAC;
  const waitingCount = trackedPedestrians.filter(p =>
    p.seenThisFrame && (p.cx < cwL || p.cx > cwR)
  ).length;

  if (waitingCount > 0) {
    cueEl.style.display = 'flex';
    cueEl.querySelector('.pwc-count').textContent = waitingCount;
    cueEl.querySelector('.pwc-label').textContent = `pedestrian(s) waiting`;
    // Reduce green proportionally based on how many are waiting â€” triggers immediately
    // More people = more aggressive reduction, applied once per cycle
    if (isToggleOn('t-smart-queue') && phaseTimer > 8 && !window._greenReducedThisCycle) {
      window._greenReducedThisCycle = true;
      // 1 person â†’ cut to 70%, 2 â†’ 55%, 3+ â†’ 40%, all min 6s
      const factor = waitingCount === 1 ? 0.70 : waitingCount === 2 ? 0.55 : 0.40;
      phaseTimer = Math.max(6, Math.floor(phaseTimer * factor));
      phaseMax = Math.max(phaseMax, phaseTimer);
      updateTimerUI();
      showToast(`ğŸ‘€ ${waitingCount} pedestrian(s) waiting â€” green cut to ${phaseTimer}s`, '#f5a623');
    }
  } else {
    cueEl.style.display = 'none';
  }
}

// â”€â”€ SNAPSHOT CAPTURE â”€â”€
function captureJaywalkerSnapshot(bbox, pedId) {
  const video = document.getElementById('video');
  const snap = document.createElement('canvas');
  snap.width  = video.videoWidth  || 640;
  snap.height = video.videoHeight || 480;
  const sCtx = snap.getContext('2d');
  // Mirror to match displayed video
  sCtx.save();
  sCtx.scale(-1, 1);
  sCtx.translate(-snap.width, 0);
  sCtx.drawImage(video, 0, 0);
  sCtx.restore();
  // Red overlay box for the jaywalker
  if (bbox) {
    const [bx,by,bw,bh] = bbox;
    const mirrorX = snap.width - bx - bw; // mirror the X for flipped canvas
    sCtx.strokeStyle = '#ef4444';
    sCtx.lineWidth = 3;
    sCtx.shadowColor = '#ef4444'; sCtx.shadowBlur = 10;
    sCtx.strokeRect(mirrorX, by, bw, bh);
    sCtx.shadowBlur = 0;
    sCtx.fillStyle = 'rgba(239,68,68,0.85)';
    sCtx.fillRect(mirrorX, by - 22, 160, 22);
    sCtx.fillStyle = '#fff';
    sCtx.font = '11px "DM Mono", monospace';
    sCtx.fillText(`ğŸ“¸ VIOLATION â€” PED #${pedId+1}`, mirrorX + 5, by - 6);
    // Timestamp
    const ts = new Date().toLocaleString();
    sCtx.fillStyle = 'rgba(0,0,0,0.7)';
    sCtx.fillRect(0, snap.height - 22, 260, 22);
    sCtx.fillStyle = '#ef4444';
    sCtx.font = '10px "DM Mono", monospace';
    sCtx.fillText(`HEN-TERSECTION VIOLATION ${ts}`, 6, snap.height - 6);
  }

  // Download the snapshot
  snap.toBlob(blob => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `jaywalk-violation-${Date.now()}.png`;
    a.click();
  }, 'image/png');

  // Also show thumbnail in detection list
  const dataUrl = snap.toDataURL('image/jpeg', 0.7);
  const list = document.getElementById('detection-list');
  const item = document.createElement('div');
  item.className = 'det-item';
  const now2 = new Date();
  const t2 = [now2.getHours(),now2.getMinutes(),now2.getSeconds()].map(v=>String(v).padStart(2,'0')).join(':');
  item.innerHTML = `
    <img src="${dataUrl}" style="width:50px;height:35px;object-fit:cover;border-radius:3px;border:1px solid #ef4444;flex-shrink:0">
    <div class="det-info">
      <div class="det-name" style="color:#ef4444">ğŸ“¸ Photo Captured</div>
      <div class="det-sub">Ped #${pedId+1} â€” 3s violation</div>
    </div>
    <span class="det-conf jay">PHOTO</span>
    <span class="det-time">${t2}</span>
  `;
  list.insertBefore(item, list.firstChild);
}

function drawZoneOverlay(ctx, w, h) {
  if (!zoneShapes.length) return;
  zoneShapes.forEach(z => {
    const scaleX = w / 800, scaleY = h / 350;
    ctx.save();
    if (z.type === 'crosswalk') {
      ctx.fillStyle = 'rgba(34,197,94,0.08)';
      ctx.strokeStyle = 'rgba(34,197,94,0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([6,4]);
      ctx.fillRect(z.x*scaleX, z.y*scaleY, z.w*scaleX, z.h*scaleY);
      ctx.strokeRect(z.x*scaleX, z.y*scaleY, z.w*scaleX, z.h*scaleY);
    } else if (z.type === 'wait') {
      ctx.fillStyle = 'rgba(59,130,246,0.08)';
      ctx.strokeStyle = 'rgba(59,130,246,0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([6,4]);
      ctx.fillRect(z.x*scaleX, z.y*scaleY, z.w*scaleX, z.h*scaleY);
      ctx.strokeRect(z.x*scaleX, z.y*scaleY, z.w*scaleX, z.h*scaleY);
    } else if (z.type === 'line') {
      ctx.strokeStyle = 'rgba(245,158,11,0.6)';
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(z.x*scaleX, z.y*scaleY);
      ctx.lineTo(z.x2*scaleX, z.y2*scaleY);
      ctx.stroke();
    }
    ctx.restore();
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VOICE / TTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function speak(key) {
  if (!isToggleOn('t-voice')) return;
  const msgEl = document.getElementById('msg-' + key);
  if (!msgEl) return;
  const msg = msgEl.value;
  if ('speechSynthesis' in window) {
    window.speechSynthesis.cancel();
    const utt = new SpeechSynthesisUtterance(msg);
    utt.rate = parseFloat(document.getElementById('r-speech-rate')?.value || 9) / 10;
    utt.volume = parseFloat(document.getElementById('r-vol')?.value || 9) / 10;
    window.speechSynthesis.speak(utt);
  }
  // Show voice bars active
  const bars = document.querySelectorAll('.voice-bars .voice-bar');
  bars.forEach(b => b.classList.add('active'));
  document.getElementById('voice-text').textContent = msg.substring(0, 50) + (msg.length > 50 ? 'â€¦' : '');
  setTimeout(() => {
    bars.forEach(b => b.classList.remove('active'));
    document.getElementById('voice-text').textContent = 'No speech';
  }, 4000);
}

function testSpeak(key) { speak(key); }

function updateVoiceBars(active) {
  const bars = document.querySelectorAll('.voice-bars .voice-bar');
  // subtle animation when detection active
  bars.forEach((b,i) => {
    b.style.height = active ? (4 + Math.floor(Math.random()*10)) + 'px' : (4+i*2)+'px';
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOAST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let toastTimer;
function showToast(msg, borderColor = 'var(--accent)') {
  const el = document.getElementById('announcement-toast');
  document.getElementById('toast-text').textContent = msg;
  el.style.borderColor = borderColor;
  el.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => el.classList.remove('show'), 3500);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DETECTION LIST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function addDetectionItem(icon, name, sub, type) {
  const list = document.getElementById('detection-list');
  // Safely remove placeholder â€” check it's still a child before removing
  const placeholder = list.querySelector('[style]');
  if (placeholder && placeholder.parentNode === list) list.removeChild(placeholder);

  const item = document.createElement('div');
  item.className = 'det-item';
  const now = new Date();
  const t = [now.getHours(), now.getMinutes(), now.getSeconds()].map(v=>String(v).padStart(2,'0')).join(':');
  item.innerHTML = `
    <span class="det-icon">${icon}</span>
    <div class="det-info">
      <div class="det-name">${name}</div>
      <div class="det-sub">${sub}</div>
    </div>
    <span class="det-conf ${type}">${type.toUpperCase()}</span>
    <span class="det-time">${t}</span>
  `;
  list.insertBefore(item, list.firstChild);
  while (list.children.length > 20) list.removeChild(list.lastChild);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EVENT LOG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let activeFilter = 'all';

function logEvent(type, isMobility) {
  const now = new Date();
  const crossTime = isMobility
    ? getSettingVal('r-default-time',20) + getSettingVal('r-mobility-ext',15)
    : getSettingVal('r-default-time',20);

  if (type === 'walk') {
    statCrossed++;
    document.getElementById('stat-crossed').textContent = statCrossed;
    crossTimes.push(crossTime);
    const avg = Math.round(crossTimes.reduce((a,b)=>a+b,0)/crossTimes.length);
    document.getElementById('stat-avgtime').textContent = avg+'s';
  }

  const entry = {
    time: [now.getHours(),now.getMinutes(),now.getSeconds()].map(v=>String(v).padStart(2,'0')).join(':'),
    date: now.toLocaleDateString(),
    type: type === 'jaywalk' ? 'jaywalk' : isMobility ? 'mobility' : 'normal',
    persons: Math.floor(Math.random()*3)+1,
    crossTime: type === 'jaywalk' ? 'â€”' : crossTime + 's',
    conf: (75 + Math.floor(Math.random()*20)) + '%',
    notes: type === 'jaywalk' ? 'Crossed on red phase' : isMobility ? 'Extended time applied' : 'Normal crossing'
  };
  eventLog.unshift(entry);
  renderLog();
}

function renderLog() {
  const tbody = document.getElementById('log-tbody');
  const filtered = activeFilter === 'all' ? eventLog : eventLog.filter(e => e.type === activeFilter);
  if (!filtered.length) {
    tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;color:var(--muted);padding:40px">No events yet</td></tr>';
    return;
  }
  const typeInfo = {
    normal: ['pill-normal','ğŸš¶ Normal'],
    mobility: ['pill-mobility','ğŸ¦½ Mobility Aid'],
    jaywalk: ['pill-jaywalk','âš ï¸ Jaywalker'],
    timeout: ['pill-timeout','â± Timeout'],
  };
  tbody.innerHTML = filtered.slice(0,200).map(e => {
    const [cls, label] = typeInfo[e.type] || ['pill-normal', e.type];
    return `<tr>
      <td class="log-mono">${e.date} ${e.time}</td>
      <td><span class="log-type-pill ${cls}">${label}</span></td>
      <td>${e.persons}</td>
      <td class="log-mono">${e.crossTime}</td>
      <td class="log-mono">${e.conf}</td>
      <td style="color:var(--muted)">${e.notes}</td>
    </tr>`;
  }).join('');
}

function filterLog(f, el) {
  activeFilter = f;
  document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  renderLog();
}

function exportLog() {
  const headers = ['Date','Time','Type','Persons','CrossTime','Confidence','Notes'];
  const rows = eventLog.map(e=>[e.date,e.time,e.type,e.persons,e.crossTime,e.conf,e.notes]);
  const csv = [headers, ...rows].map(r=>r.join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'smartcross-log.csv';
  a.click();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CROSSWALK ZONE EDITOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const zoneColors = {
  crosswalk: { fill:'rgba(34,197,94,0.15)', stroke:'rgba(34,197,94,0.8)' },
  wait: { fill:'rgba(59,130,246,0.15)', stroke:'rgba(59,130,246,0.8)' },
  line: { fill: null, stroke:'rgba(245,158,11,0.9)' }
};

let zoneShapes = [];
let currentTool = 'crosswalk';
let drawing = false;
let startX = 0, startY = 0;
let selectedZone = null;
let dragStart = null;

function setTool(t, el) {
  currentTool = t;
  document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
}

function clearZones() {
  zoneShapes = [];
  renderZoneCanvas();
  updateZoneCount();
}

function updateZoneCount() {
  document.getElementById('zone-count').textContent = zoneShapes.length + ' zone' + (zoneShapes.length!==1?'s':'') + ' defined';
}

function renderZoneCanvas() {
  const canvas = document.getElementById('crosswalk-canvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  // â”€â”€ Front-on crosswalk view â”€â”€
  // Camera faces the crosswalk straight-on.
  // Left third = left pavement/wait area
  // Middle third = crosswalk / road
  // Right third = right pavement/wait area

  const cwL = W * CW_LEFT_FRAC;
  const cwR = W * CW_RIGHT_FRAC;

  // Sky at top ~35%
  const skyH = Math.round(H * 0.35);
  const skyGrad = ctx.createLinearGradient(0, 0, 0, skyH);
  skyGrad.addColorStop(0, '#0c0e16'); skyGrad.addColorStop(1, '#141825');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, skyH);

  // Buildings left side â€” behind left pavement
  const leftBldgs = [
    {x:0,   w:70, h:100}, {x:80,  w:50, h:80 }, {x:140, w:80, h:120},
  ];
  leftBldgs.forEach(b => {
    ctx.fillStyle = '#11151e';
    ctx.fillRect(b.x, skyH - b.h, Math.min(b.w, cwL - b.x), b.h);
    ctx.fillStyle = 'rgba(255,240,120,0.06)';
    for (let wy = skyH - b.h + 10; wy < skyH - 10; wy += 16)
      for (let wx = b.x + 6; wx < b.x + b.w - 8 && wx < cwL - 4; wx += 12)
        if ((wx+wy) % 24 < 12) ctx.fillRect(wx, wy, 7, 9);
  });
  // Buildings right side
  const rightBldgs = [
    {x:cwR+10, w:70, h:110}, {x:cwR+100, w:60, h:85}, {x:cwR+170, w:90, h:130},
  ];
  rightBldgs.forEach(b => {
    ctx.fillStyle = '#11151e';
    ctx.fillRect(b.x, skyH - b.h, b.w, b.h);
    ctx.fillStyle = 'rgba(255,240,120,0.06)';
    for (let wy = skyH - b.h + 10; wy < skyH - 10; wy += 16)
      for (let wx = b.x + 6; wx < b.x + b.w - 8; wx += 12)
        if ((wx+wy) % 24 < 12) ctx.fillRect(wx, wy, 7, 9);
  });

  // Distant road visible above crosswalk (road recedes into distance at top of road section)
  const roadTopY = skyH;
  const roadBotY = H;
  ctx.fillStyle = '#1c2030';
  ctx.fillRect(cwL, roadTopY, cwR - cwL, roadBotY - roadTopY);

  // Left pavement
  const pavGrad = ctx.createLinearGradient(0, roadTopY, 0, roadBotY);
  pavGrad.addColorStop(0, '#1a1e2c'); pavGrad.addColorStop(1, '#1e2234');
  ctx.fillStyle = pavGrad;
  ctx.fillRect(0, roadTopY, cwL, roadBotY - roadTopY);

  // Right pavement
  ctx.fillStyle = pavGrad;
  ctx.fillRect(cwR, roadTopY, W - cwR, roadBotY - roadTopY);

  // Pavement texture tiles
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  const tile = 28;
  for (let tx = 0; tx < cwL; tx += tile*2)
    for (let ty = roadTopY; ty < roadBotY; ty += tile*2) {
      ctx.fillRect(tx, ty, tile, tile);
      ctx.fillRect(tx+tile, ty+tile, tile, tile);
    }
  for (let tx = cwR; tx < W; tx += tile*2)
    for (let ty = roadTopY; ty < roadBotY; ty += tile*2) {
      ctx.fillRect(tx, ty, tile, tile);
      ctx.fillRect(tx+tile, ty+tile, tile, tile);
    }

  // Kerb lines (vertical edges of crosswalk)
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 2; ctx.setLineDash([]);
  ctx.beginPath();
  ctx.moveTo(cwL, roadTopY); ctx.lineTo(cwL, roadBotY);
  ctx.moveTo(cwR, roadTopY); ctx.lineTo(cwR, roadBotY);
  ctx.stroke();

  // Zebra crosswalk stripes (horizontal bands across the road column)
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  const nStripes = 7;
  const stripeH = (roadBotY - roadTopY) / (nStripes * 2 - 1);
  for (let s = 0; s < nStripes; s++) {
    ctx.fillRect(cwL + 2, roadTopY + s * stripeH * 2, cwR - cwL - 4, stripeH);
  }

  // Road lane direction arrows (subtle, going leftâ†’right in crossing zone)
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.font = 'bold 28px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('â†’', cwL + (cwR-cwL)*0.5, roadTopY + (roadBotY-roadTopY)*0.35);
  ctx.fillText('â†', cwL + (cwR-cwL)*0.5, roadTopY + (roadBotY-roadTopY)*0.65);
  ctx.textAlign = 'left';

  // Traffic light pole â€” right kerb edge
  const tlx = cwR + 18, tly = roadTopY + 10;
  ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 3; ctx.setLineDash([]);
  ctx.beginPath(); ctx.moveTo(tlx, tly + 80); ctx.lineTo(tlx, tly); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(tlx, tly); ctx.lineTo(tlx - 18, tly); ctx.stroke();
  // Housing
  const isGreen  = crossingPhase === 'ew-green' || crossingPhase === 'ns-green';
  const isYellow = crossingPhase === 'ew-yellow' || crossingPhase === 'ns-yellow';
  const isRed    = !isGreen && !isYellow;
  ctx.fillStyle = '#111'; ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.roundRect(tlx - 26, tly - 2, 14, 28, 2); ctx.fill(); ctx.stroke();
  [{c: isRed?'#ef4444':'rgba(239,68,68,0.12)', g:isRed?'#ef4444':null, oy:4},
   {c: isYellow?'#f59e0b':'rgba(245,158,11,0.12)', g:isYellow?'#f59e0b':null, oy:12},
   {c: isGreen?'#22c55e':'rgba(34,197,94,0.12)',  g:isGreen?'#22c55e':null, oy:20}
  ].forEach(b => {
    if (b.g) { ctx.shadowColor = b.g; ctx.shadowBlur = 7; }
    ctx.fillStyle = b.c;
    ctx.beginPath(); ctx.arc(tlx - 19, tly + b.oy, 4, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
  });

  // Labels
  ctx.fillStyle = 'rgba(255,255,255,0.22)';
  ctx.font = '10px DM Mono, monospace';
  ctx.textAlign = 'center';
  ctx.fillText('WAIT ZONE', cwL / 2, roadTopY + 22);
  ctx.fillText('CROSSWALK', cwL + (cwR - cwL) / 2, roadTopY + 22);
  ctx.fillText('WAIT ZONE', cwR + (W - cwR) / 2, roadTopY + 22);
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillText('â—€ LEFT PAVEMENT', cwL / 2, H - 12);
  ctx.fillText('ROAD â†•', cwL + (cwR - cwL) / 2, H - 12);
  ctx.fillText('RIGHT PAVEMENT â–¶', cwR + (W - cwR) / 2, H - 12);
  ctx.textAlign = 'left';

  // Draw zones
  zoneShapes.forEach((z, idx) => {
    const c = zoneColors[z.type];
    ctx.save();
    if (z.type === 'line') {
      ctx.strokeStyle = c.stroke;
      ctx.lineWidth = 3;
      ctx.setLineDash([]);
      ctx.shadowColor = c.stroke;
      ctx.shadowBlur = 4;
      ctx.beginPath();
      ctx.moveTo(z.x, z.y);
      ctx.lineTo(z.x2, z.y2);
      ctx.stroke();
      // Arrows
      const angle = Math.atan2(z.y2-z.y, z.x2-z.x);
      const mx = (z.x+z.x2)/2, my = (z.y+z.y2)/2;
      ctx.beginPath();
      ctx.moveTo(mx, my);
      ctx.lineTo(mx - 10*Math.cos(angle-0.4), my - 10*Math.sin(angle-0.4));
      ctx.moveTo(mx, my);
      ctx.lineTo(mx - 10*Math.cos(angle+0.4), my - 10*Math.sin(angle+0.4));
      ctx.stroke();
    } else {
      ctx.fillStyle = c.fill;
      ctx.strokeStyle = selectedZone === idx ? '#fff' : c.stroke;
      ctx.lineWidth = selectedZone === idx ? 2 : 1.5;
      ctx.setLineDash(selectedZone === idx ? [] : [6,4]);
      ctx.shadowColor = c.stroke;
      ctx.shadowBlur = selectedZone === idx ? 8 : 3;
      ctx.fillRect(z.x, z.y, z.w, z.h);
      ctx.strokeRect(z.x, z.y, z.w, z.h);
      // Label
      ctx.fillStyle = c.stroke;
      ctx.font = '10px DM Mono, monospace';
      ctx.setLineDash([]);
      ctx.shadowBlur = 0;
      ctx.fillText(z.type.toUpperCase(), z.x+5, z.y+14);
    }
    ctx.restore();
  });
}

const zCanvas = document.getElementById('crosswalk-canvas');

zCanvas.addEventListener('mousedown', e => {
  const r = zCanvas.getBoundingClientRect();
  const scaleX = zCanvas.width / r.width;
  const scaleY = zCanvas.height / r.height;
  startX = (e.clientX - r.left) * scaleX;
  startY = (e.clientY - r.top) * scaleY;
  drawing = true;

  if (currentTool === 'select') {
    selectedZone = null;
    for (let i = zoneShapes.length-1; i >= 0; i--) {
      const z = zoneShapes[i];
      if (z.type !== 'line' && startX >= z.x && startX <= z.x+z.w && startY >= z.y && startY <= z.y+z.h) {
        selectedZone = i;
        dragStart = { mx: startX, my: startY, zx: z.x, zy: z.y };
        break;
      }
    }
    renderZoneCanvas();
  }
});

zCanvas.addEventListener('mousemove', e => {
  if (!drawing) return;
  const r = zCanvas.getBoundingClientRect();
  const scaleX = zCanvas.width / r.width;
  const scaleY = zCanvas.height / r.height;
  const cx = (e.clientX - r.left) * scaleX;
  const cy = (e.clientY - r.top) * scaleY;

  if (currentTool === 'select' && selectedZone !== null && dragStart) {
    zoneShapes[selectedZone].x = dragStart.zx + (cx - dragStart.mx);
    zoneShapes[selectedZone].y = dragStart.zy + (cy - dragStart.my);
    renderZoneCanvas();
    return;
  }

  renderZoneCanvas();
  const ctx = zCanvas.getContext('2d');
  if (currentTool === 'line') {
    ctx.strokeStyle = zoneColors.line.stroke;
    ctx.lineWidth = 2;
    ctx.setLineDash([4,4]);
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(cx, cy);
    ctx.stroke();
  } else {
    const col = zoneColors[currentTool] || zoneColors.crosswalk;
    ctx.fillStyle = col.fill;
    ctx.strokeStyle = col.stroke;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6,4]);
    ctx.fillRect(startX, startY, cx-startX, cy-startY);
    ctx.strokeRect(startX, startY, cx-startX, cy-startY);
  }
});

zCanvas.addEventListener('mouseup', e => {
  if (!drawing) return;
  drawing = false;
  dragStart = null;
  const r = zCanvas.getBoundingClientRect();
  const scaleX = zCanvas.width / r.width;
  const scaleY = zCanvas.height / r.height;
  const ex = (e.clientX - r.left) * scaleX;
  const ey = (e.clientY - r.top) * scaleY;

  if (currentTool === 'select') return;

  if (Math.abs(ex-startX) < 5 && Math.abs(ey-startY) < 5) return;

  if (currentTool === 'line') {
    zoneShapes.push({ type:'line', x:startX, y:startY, x2:ex, y2:ey });
  } else {
    zoneShapes.push({ type:currentTool, x:Math.min(startX,ex), y:Math.min(startY,ey), w:Math.abs(ex-startX), h:Math.abs(ey-startY) });
  }
  renderZoneCanvas();
  updateZoneCount();
});

zCanvas.addEventListener('dblclick', e => {
  const r = zCanvas.getBoundingClientRect();
  const scaleX = zCanvas.width / r.width;
  const scaleY = zCanvas.height / r.height;
  const cx = (e.clientX - r.left) * scaleX;
  const cy = (e.clientY - r.top) * scaleY;
  zoneShapes = zoneShapes.filter(z => {
    if (z.type === 'line') return true;
    return !(cx>=z.x && cx<=z.x+z.w && cy>=z.y && cy<=z.y+z.h);
  });
  renderZoneCanvas();
  updateZoneCount();
});

renderZoneCanvas();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SAVE SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function saveSettings() {
  showToast('âœ… Settings saved successfully', '#22c55e');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEED SOME DEMO LOG DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function seedLog() {
  const types = ['normal','normal','normal','mobility','jaywalk','normal','mobility','normal'];
  types.forEach((t, i) => {
    const d = new Date(Date.now() - (types.length-i)*4*60000);
    const ct = t === 'mobility' ? 35 : t === 'jaywalk' ? null : 20;
    eventLog.push({
      time: [d.getHours(),d.getMinutes(),d.getSeconds()].map(v=>String(v).padStart(2,'0')).join(':'),
      date: d.toLocaleDateString(),
      type: t,
      persons: Math.floor(Math.random()*3)+1,
      crossTime: ct ? ct+'s' : 'â€”',
      conf: (78+Math.floor(Math.random()*17))+'%',
      notes: t==='jaywalk'?'Crossed on red phase':t==='mobility'?'Extended time applied':'Normal crossing'
    });
    if (t==='normal'||t==='mobility') { statCrossed++; crossTimes.push(ct); }
    if (t==='jaywalk') statJay++;
    if (t==='mobility') statMobility++;
  });
  document.getElementById('stat-crossed').textContent = statCrossed;
  document.getElementById('stat-jay').textContent = statJay;
  document.getElementById('stat-mobility').textContent = statMobility;
  const avg = Math.round(crossTimes.reduce((a,b)=>a+b,0)/crossTimes.length);
  document.getElementById('stat-avgtime').textContent = avg+'s';
  renderLog();
}

// TRAFFIC SIMULATION ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const simCanvas = document.getElementById('sim-canvas');
const simCtx = simCanvas.getContext('2d');
let simRunning = false;
let simSpeed = 1.0;
let simAnimId = null;
let simLastTime = 0;
let simCars = [];
let simCarIdCounter = 0;
let simStatPassed = 0;
let simStatStopped = 0;
let simWaitTimes = [];
let simSpawnTimer = 0;
let simEvtList = [];

// Colors for cars
const CAR_COLORS = [
  '#3b82f6','#8b5cf6','#f5a623','#22c55e','#ef4444',
  '#06b6d4','#ec4899','#f59e0b','#10b981','#6366f1'
];

// Car config
const CAR_W = 28, CAR_H = 16;
const ROAD_W = 90; // total road width (2 lanes Ã— 45)
const LANE_W = 45;
const STOP_MARGIN = 14; // px before stop line

function getSimDimensions() {
  const r = simCanvas.getBoundingClientRect();
  return { w: simCanvas.width, h: simCanvas.height, cx: simCanvas.width/2, cy: simCanvas.height/2 };
}

// â”€â”€â”€ LANE CENTERS (car.x/y is the CENTER of the car) â”€â”€â”€
// EW road occupies cy-ROAD_W/2 to cy+ROAD_W/2
//   East lane (heading right): center = cy - ROAD_W/4   (top half center)
//   West lane (heading left):  center = cy + ROAD_W/4   (bottom half center)
// NS road occupies cx-ROAD_W/2 to cx+ROAD_W/2
//   South lane (heading down): center = cx - ROAD_W/4   (left half center)
//   North lane (heading up):   center = cx + ROAD_W/4   (right half center)
function getLaneCenter(dir) {
  const { cx, cy, h, w } = getSimDimensions();
  if (simViewMode === 'sideon') {
    const roadTop = h * 0.62;
    const laneH   = 46;
    if (dir === 'east')  return roadTop + laneH/2;          // top lane y-center
    if (dir === 'west')  return roadTop + laneH + laneH/2;  // bottom lane y-center
    // sideon only has EW â€” NS shouldn't spawn, but safe fallback
    if (dir === 'south') return cx - ROAD_W/4;
    if (dir === 'north') return cx + ROAD_W/4;
  }
  if (simViewMode === 'horizontal') {
    // Single horizontal road â€” only EW lanes
    if (dir === 'east')  return cy - ROAD_W/4;
    if (dir === 'west')  return cy + ROAD_W/4;
    if (dir === 'south') return cx - ROAD_W/4;
    if (dir === 'north') return cx + ROAD_W/4;
  }
  if (simViewMode === 'vertical') {
    // Single vertical road â€” only NS lanes
    if (dir === 'east')  return cy - ROAD_W/4;
    if (dir === 'west')  return cy + ROAD_W/4;
    if (dir === 'south') return cx - ROAD_W/4;
    if (dir === 'north') return cx + ROAD_W/4;
  }
  // Default intersection mode
  if (dir === 'east')  return cy - ROAD_W/4;
  if (dir === 'west')  return cy + ROAD_W/4;
  if (dir === 'south') return cx - ROAD_W/4;
  if (dir === 'north') return cx + ROAD_W/4;
}

// Spawn a new car
function spawnCar(dir, laneIndex) {
  // Guard: don't spawn NS cars in EW-only views, or EW cars in vertical view
  if ((simViewMode === 'horizontal' || simViewMode === 'sideon') && (dir === 'north' || dir === 'south')) return;
  if (simViewMode === 'vertical' && (dir === 'east' || dir === 'west')) return;

  const { w, h, cx, cy } = getSimDimensions();

  const laneCenter = getLaneCenter(dir);
  const off = 80;
  let sx, sy;
  if (dir === 'east')  { sx = -off;  sy = laneCenter; }  // laneCenter = y pos for EW
  if (dir === 'west')  { sx = w+off; sy = laneCenter; }
  if (dir === 'south') { sx = laneCenter; sy = -off;  }  // laneCenter = x pos for NS
  if (dir === 'north') { sx = laneCenter; sy = h+off; }

  // Don't spawn if another car is too close to the entry point
  const tooClose = simCars.some(c => {
    if (c.dir !== dir) return false;
    const d = Math.abs((dir==='east'||dir==='west') ? c.x - sx : c.y - sy);
    return d < 70;
  });
  if (tooClose) return;

  const car = {
    id: simCarIdCounter++,
    dir,
    color: CAR_COLORS[simCarIdCounter % CAR_COLORS.length],
    speed: (1.5 + Math.random()*0.6) * 60, // px/sec base speed
    currentSpeed: (1.5 + Math.random()*0.6) * 60,
    state: 'moving',
    waitTime: 0,
    hasWaited: false,
    x: sx, y: sy,
  };

  simCars.push(car);
}

function spawnCarManual(axis) {
  if (simViewMode === 'horizontal' || simViewMode === 'sideon') {
    // These views only have EW road â€” only spawn EW cars regardless of button pressed
    spawnCar(Math.random()<0.5?'east':'west', 0);
  } else if (simViewMode === 'vertical') {
    // Vertical view only has NS road
    spawnCar(Math.random()<0.5?'north':'south', 0);
  } else if (axis === 'horizontal') {
    spawnCar(Math.random()<0.5?'east':'west', 0);
  } else {
    spawnCar(Math.random()<0.5?'north':'south', 0);
  }
}

// â”€â”€ SIMULATION VIEW MODE â”€â”€
let simViewMode = 'sideon'; // 'intersection' | 'horizontal' | 'vertical' | 'sideon'

function setSimView(mode) {
  simViewMode = mode;
  ['intersection','horizontal','vertical','sideon'].forEach(m => {
    const opt = document.getElementById('view-opt-' + m);
    if (opt) {
      opt.classList.toggle('sim-view-option-active', m === mode);
      const radio = opt.querySelector('input[type=radio]');
      if (radio) radio.checked = (m === mode);
    }
  });
  simCars = [];
  if (mode === 'horizontal' || mode === 'sideon') {
    setPhase('ew-green');
    addSimEvent((mode === 'sideon' ? 'ğŸ™ Side-On' : 'â†” Horizontal') + ' view active', 'highlight');
  } else if (mode === 'vertical') {
    setPhase('ns-green');
    addSimEvent('â†• Vertical Road view active', 'highlight');
  } else {
    setPhase('ew-green');
    addSimEvent('ğŸš¦ Intersection view active', 'highlight');
  }
}

function autoSpawn() {
  const density = parseInt(document.getElementById('sim-density')?.value||2);
  const interval = [8,5,3.5,2.5,1.5][density-1];
  simSpawnTimer += 1/60 * simSpeed;
  if (simSpawnTimer >= interval) {
    simSpawnTimer = 0;
    if (simViewMode === 'horizontal' || simViewMode === 'sideon') {
      spawnCar(Math.random()<0.5?'east':'west', 0);
    } else if (simViewMode === 'vertical') {
      spawnCar(Math.random()<0.5?'north':'south', 0);
    } else {
      const dirs = ['east','west','north','south'];
      spawnCar(dirs[Math.floor(Math.random()*4)], 0);
    }
  }
}

// Stop line offset from intersection edge: crosswalk gap + crosswalk width + gap before stop line
const STOP_LINE_OFFSET = 4 + (5 * (6 + 5) - 5) + 8; // = 4 + 50 + 8 = 62px

function getStopLine(dir) {
  const { cx, cy } = getSimDimensions();
  // In intersection mode cars stop beyond the intersection box (ROAD_W/2 from center) plus crosswalk
  // In single-road/sideon modes the crosswalk is centered at cx/cy directly
  const boxOffset = (simViewMode === 'intersection') ? ROAD_W/2 : 0;
  switch(dir) {
    case 'east':  return cx - boxOffset - STOP_LINE_OFFSET;
    case 'west':  return cx + boxOffset + STOP_LINE_OFFSET;
    case 'north': return cy + boxOffset + STOP_LINE_OFFSET;
    case 'south': return cy - boxOffset - STOP_LINE_OFFSET;
  }
}

function carShouldStop(car) {
  const isEW = car.dir === 'east' || car.dir === 'west';
  // In single-road or sideon modes only ped phases stop traffic
  if (simViewMode === 'horizontal' || simViewMode === 'sideon' || simViewMode === 'vertical') {
    return crossingPhase === 'pedestrian-walk' || crossingPhase === 'pedestrian-warn';
  }
  // Intersection mode â€” each axis stops when the other has green, or during ped phases
  if (isEW) {
    return crossingPhase === 'ns-green' || crossingPhase === 'ns-yellow' ||
           crossingPhase === 'pedestrian-walk' || crossingPhase === 'pedestrian-warn';
  }
  // NS cars
  return crossingPhase === 'ew-green' || crossingPhase === 'ew-yellow' ||
         crossingPhase === 'pedestrian-walk' || crossingPhase === 'pedestrian-warn';
}

function isCarPastStopLine(car) {
  const sl = getStopLine(car.dir);
  if (car.dir === 'east')  return car.x > sl;
  if (car.dir === 'west')  return car.x < sl;
  if (car.dir === 'north') return car.y < sl;
  if (car.dir === 'south') return car.y > sl;
}

function distToStopLine(car) {
  const sl = getStopLine(car.dir);
  if (car.dir === 'east')  return sl - car.x;
  if (car.dir === 'west')  return car.x - sl;
  if (car.dir === 'north') return car.y - sl;
  if (car.dir === 'south') return sl - car.y;
}

function isCarOffscreen(car) {
  const { w, h } = getSimDimensions();
  const margin = 80;
  return car.x < -margin || car.x > w+margin || car.y < -margin || car.y > h+margin;
}

function updateCars(dt) {
  const CAR_LEN = 36; // length of car body along travel axis
  const MIN_GAP = 10; // minimum gap between cars (bumper to bumper)
  const FOLLOW_DIST = CAR_LEN + MIN_GAP; // headway target

  for (let i = simCars.length - 1; i >= 0; i--) {
    const car = simCars[i];

    // â”€â”€ 1. STOP LINE CONSTRAINT â”€â”€
    const shouldStopAtLine = carShouldStop(car);
    const pastStop = isCarPastStopLine(car);
    const distSL = distToStopLine(car);

    // â”€â”€ 2. CAR-FOLLOWING CONSTRAINT â”€â”€
    // Find the nearest car ahead in the same direction (same lane)
    let distAhead = Infinity;
    for (let j = 0; j < simCars.length; j++) {
      if (i === j) continue;
      const other = simCars[j];
      if (other.dir !== car.dir) continue;
      // "Ahead" means further along the direction of travel
      let gap;
      if (car.dir === 'east')  gap = other.x - car.x;
      if (car.dir === 'west')  gap = car.x - other.x;
      if (car.dir === 'south') gap = other.y - car.y;
      if (car.dir === 'north') gap = car.y - other.y;
      if (gap > 0 && gap < distAhead) distAhead = gap;
    }
    // Effective gap = distance to front bumper of car ahead
    const gapAhead = distAhead - CAR_LEN;

    // â”€â”€ 3. COMPUTE DESIRED SPEED â”€â”€
    let desiredSpeed = car.speed;

    // Slow for car ahead
    if (gapAhead < FOLLOW_DIST * 3) {
      // Smooth deceleration curve
      desiredSpeed = Math.min(desiredSpeed, car.speed * Math.max(0, (gapAhead - MIN_GAP) / (FOLLOW_DIST * 2)));
    }
    if (gapAhead <= MIN_GAP) {
      desiredSpeed = 0;
    }

    // Slow for stop line (if red and not already past it)
    if (shouldStopAtLine && !pastStop) {
      const brakeZone = car.speed * 1.6;
      if (distSL < brakeZone) {
        const stopFactor = Math.max(0, (distSL - 1) / brakeZone);
        desiredSpeed = Math.min(desiredSpeed, car.speed * stopFactor);
      }
      if (distSL <= 1) desiredSpeed = 0;
    }

    // â”€â”€ 4. SMOOTH SPEED TOWARDS DESIRED â”€â”€
    const accel = desiredSpeed > car.currentSpeed ? car.speed * 1.5 : car.speed * 3.0;
    if (car.currentSpeed < desiredSpeed) {
      car.currentSpeed = Math.min(desiredSpeed, car.currentSpeed + accel * dt);
    } else {
      car.currentSpeed = Math.max(desiredSpeed, car.currentSpeed - accel * dt);
    }

    // â”€â”€ 5. CLAMP: don't creep past stop line when red â”€â”€
    if (shouldStopAtLine && !pastStop && distSL < 2) {
      car.currentSpeed = 0;
      // hard-stop exactly at line
      const sl = getStopLine(car.dir);
      if (car.dir === 'east')  car.x = Math.min(car.x, sl);
      if (car.dir === 'west')  car.x = Math.max(car.x, sl);
      if (car.dir === 'north') car.y = Math.max(car.y, sl);
      if (car.dir === 'south') car.y = Math.min(car.y, sl);
    }

    // â”€â”€ 6. UPDATE STATE FOR DISPLAY â”€â”€
    car.state = car.currentSpeed < 1 ? 'stopped' : car.currentSpeed < car.speed * 0.5 ? 'slowing' : 'moving';

    // Track wait time
    if (car.state === 'stopped') {
      car.waitTime += dt;
      if (!car.hasWaited) {
        car.hasWaited = true;
        simStatStopped++;
        document.getElementById('sim-stat-stopped').textContent = simStatStopped;
      }
    } else if (car.state === 'moving' && car.hasWaited && car.waitTime > 0) {
      simWaitTimes.push(car.waitTime);
      car.waitTime = 0;
      if (simWaitTimes.length > 50) simWaitTimes.shift();
      const avg = Math.round(simWaitTimes.reduce((a,b)=>a+b,0)/simWaitTimes.length);
      document.getElementById('sim-stat-avgwait').textContent = avg + 's';
    }

    // â”€â”€ 7. LOCK Y (EW cars) or X (NS cars) to lane center â”€â”€
    const lc = getLaneCenter(car.dir);
    if (car.dir === 'east' || car.dir === 'west') car.y = lc;
    else car.x = lc;

    // â”€â”€ 8. MOVE â”€â”€
    const move = car.currentSpeed * dt;
    if (car.dir === 'east')  car.x += move;
    if (car.dir === 'west')  car.x -= move;
    if (car.dir === 'south') car.y += move;
    if (car.dir === 'north') car.y -= move;

    // â”€â”€ 9. REMOVE OFFSCREEN â”€â”€
    if (isCarOffscreen(car)) {
      simCars.splice(i, 1);
      simStatPassed++;
      document.getElementById('sim-stat-passed').textContent = simStatPassed;
    }
  }

  // Update sidebar stats
  document.getElementById('sim-stat-active').textContent = simCars.length;
  const queues = { east:0, west:0, north:0, south:0 };
  simCars.forEach(c => { if (c.state !== 'moving') queues[c.dir]++; });
  const maxQ = 6;
  ['east','west','north','south'].forEach(d => {
    const n = queues[d];
    document.getElementById('q-'+d).style.width = Math.min(100, n/maxQ*100) + '%';
    document.getElementById('q-'+d+'-n').textContent = n;
  });
}

function drawRoad() {
  const { w, h, cx, cy } = getSimDimensions();
  const ctx = simCtx;

  // Background city blocks
  ctx.fillStyle = '#0e1118';
  ctx.fillRect(0, 0, w, h);

  // Pavement checker tiles (sidewalk areas only â€” avoid road zones)
  ctx.fillStyle = '#131720';
  const tile = 36;
  for (let bx = 0; bx < w; bx += tile*2) {
    for (let by = 0; by < h; by += tile*2) {
      ctx.fillRect(bx, by, tile, tile);
      ctx.fillRect(bx+tile, by+tile, tile, tile);
    }
  }

  // â”€â”€ ROAD SURFACES â”€â”€
  const RW = ROAD_W; // 90px
  ctx.fillStyle = '#22263a';
  // Horizontal road (EW)
  ctx.fillRect(0, cy - RW/2, w, RW);
  // Vertical road (NS)
  ctx.fillRect(cx - RW/2, 0, RW, h);
  // Intersection (slightly lighter)
  ctx.fillStyle = '#272b3f';
  ctx.fillRect(cx - RW/2, cy - RW/2, RW, RW);

  // â”€â”€ LANE DIVIDERS (dashed yellow center lines) â”€â”€
  ctx.strokeStyle = 'rgba(255,210,40,0.5)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([18, 14]);
  ctx.beginPath();
  // Horizontal center line (splits EW road into eastbound top / westbound bottom)
  ctx.moveTo(0, cy);            ctx.lineTo(cx - RW/2, cy);
  ctx.moveTo(cx + RW/2, cy);   ctx.lineTo(w, cy);
  // Vertical center line (splits NS road into southbound left / northbound right)
  ctx.moveTo(cx, 0);            ctx.lineTo(cx, cy - RW/2);
  ctx.moveTo(cx, cy + RW/2);   ctx.lineTo(cx, h);
  ctx.stroke();
  ctx.setLineDash([]);

  // â”€â”€ ROAD EDGE LINES â”€â”€
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1.5;
  const EW_top = cy - RW/2, EW_bot = cy + RW/2;
  const NS_lft = cx - RW/2, NS_rgt = cx + RW/2;
  const segments = [
    // EW road top edge (left and right of intersection)
    [0, EW_top, NS_lft, EW_top], [NS_rgt, EW_top, w, EW_top],
    // EW road bottom edge
    [0, EW_bot, NS_lft, EW_bot], [NS_rgt, EW_bot, w, EW_bot],
    // NS road left edge
    [NS_lft, 0, NS_lft, EW_top], [NS_lft, EW_bot, NS_lft, h],
    // NS road right edge
    [NS_rgt, 0, NS_rgt, EW_top], [NS_rgt, EW_bot, NS_rgt, h],
  ];
  segments.forEach(([x1,y1,x2,y2]) => {
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  });

  // â”€â”€ STOP LINES & CROSSWALKS â”€â”€
  // Layout (for each approach):
  //   intersection edge â†’ [CROSS_GAP=4] â†’ [crosswalk stripes ~50px] â†’ [STOP_GAP=8] â†’ stop line â†’ cars queue here
  const CROSS_GAP  = 4;   // gap between intersection box edge and first stripe
  const SW = 6, SG = 5, nStripes = 5;
  const CROSS_W = nStripes * (SW + SG) - SG; // 50px total crosswalk width
  const STOP_GAP   = 8;   // gap between last stripe and stop line
  const SL_OFFSET  = CROSS_GAP + CROSS_W + STOP_GAP; // distance from intersection edge to stop line

  // Override STOP_MARGIN visually for stop line drawing (JS getStopLine uses the const, we redraw here)
  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
  ctx.lineWidth = 2.5;
  ctx.setLineDash([]);
  ctx.beginPath();
  // Eastbound stop line â€” left of intersection
  ctx.moveTo(cx - RW/2 - SL_OFFSET, cy - RW/2); ctx.lineTo(cx - RW/2 - SL_OFFSET, cy);
  // Westbound stop line â€” right of intersection
  ctx.moveTo(cx + RW/2 + SL_OFFSET, cy);         ctx.lineTo(cx + RW/2 + SL_OFFSET, cy + RW/2);
  // Southbound stop line â€” top of intersection
  ctx.moveTo(cx - RW/2, cy - RW/2 - SL_OFFSET);  ctx.lineTo(cx, cy - RW/2 - SL_OFFSET);
  // Northbound stop line â€” bottom of intersection
  ctx.moveTo(cx, cy + RW/2 + SL_OFFSET);          ctx.lineTo(cx + RW/2, cy + RW/2 + SL_OFFSET);
  ctx.stroke();

  // â”€â”€ CROSSWALK STRIPES â€” between intersection edge and stop line â”€â”€
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  for (let s = 0; s < nStripes; s++) {
    const so = CROSS_GAP + s * (SW + SG);
    // Top crosswalk (above intersection) â€” stripes go upward from intersection top edge
    ctx.fillRect(NS_lft, cy - RW/2 - so - SW, RW, SW);
    // Bottom crosswalk â€” stripes go downward from intersection bottom edge
    ctx.fillRect(NS_lft, cy + RW/2 + so, RW, SW);
    // Left crosswalk â€” stripes go leftward from intersection left edge
    ctx.fillRect(cx - RW/2 - so - SW, EW_top, SW, RW);
    // Right crosswalk â€” stripes go rightward from intersection right edge
    ctx.fillRect(cx + RW/2 + so, EW_top, SW, RW);
  }

  // â”€â”€ TRAFFIC LIGHT POLES (4 corners) â”€â”€
  drawTrafficLightPole(ctx, NS_lft - 12, EW_top - 12, 'ns');
  drawTrafficLightPole(ctx, NS_rgt + 12, EW_top - 12, 'ew');
  drawTrafficLightPole(ctx, NS_lft - 12, EW_bot + 12, 'ew');
  drawTrafficLightPole(ctx, NS_rgt + 12, EW_bot + 12, 'ns');
}

function drawTrafficLightPole(ctx, x, y, axis) {
  // axis: 'ew' for east/west lights, 'ns' for north/south lights
  const isGreen  = axis === 'ew' ? crossingPhase === 'ew-green'  : crossingPhase === 'ns-green';
  const isYellow = axis === 'ew' ? crossingPhase === 'ew-yellow' : crossingPhase === 'ns-yellow';
  const isRed    = !isGreen && !isYellow;

  // Pole
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x,y-2); ctx.stroke();

  // Light housing
  ctx.fillStyle = '#111';
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(x-7, y-24, 14, 26, 3);
  ctx.fill(); ctx.stroke();

  // Bulbs
  const bulbs = [
    { color: isRed ? '#ef4444' : 'rgba(239,68,68,0.12)', glow: isRed ? '#ef4444' : null, oy: -20 },
    { color: isYellow ? '#f59e0b' : 'rgba(245,158,11,0.12)', glow: isYellow ? '#f59e0b' : null, oy: -12 },
    { color: isGreen ? '#22c55e' : 'rgba(34,197,94,0.12)', glow: isGreen ? '#22c55e' : null, oy: -4 },
  ];
  bulbs.forEach(b => {
    if (b.glow) { ctx.shadowColor = b.glow; ctx.shadowBlur = 6; }
    ctx.fillStyle = b.color;
    ctx.beginPath(); ctx.arc(x, y+b.oy, 4, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
  });
}

// â”€â”€ SINGLE ROAD VIEW (horizontal or vertical) â”€â”€
function drawRoadSingle(orientation) {
  const { w, h, cx, cy } = getSimDimensions();
  const ctx = simCtx;
  const RW = ROAD_W;
  const isH = orientation === 'horizontal';

  // Background
  ctx.fillStyle = '#0e1118';
  ctx.fillRect(0, 0, w, h);
  ctx.fillStyle = '#131720';
  const tile = 36;
  for (let bx = 0; bx < w; bx += tile*2)
    for (let by = 0; by < h; by += tile*2) {
      ctx.fillRect(bx, by, tile, tile);
      ctx.fillRect(bx+tile, by+tile, tile, tile);
    }

  // Road surface
  ctx.fillStyle = '#22263a';
  if (isH) {
    ctx.fillRect(0, cy - RW/2, w, RW);
  } else {
    ctx.fillRect(cx - RW/2, 0, RW, h);
  }

  // Center line
  ctx.strokeStyle = 'rgba(255,210,40,0.5)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([18, 14]);
  ctx.beginPath();
  if (isH) { ctx.moveTo(0, cy); ctx.lineTo(w, cy); }
  else      { ctx.moveTo(cx, 0); ctx.lineTo(cx, h); }
  ctx.stroke();
  ctx.setLineDash([]);

  // Road edges
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  if (isH) {
    ctx.moveTo(0, cy-RW/2); ctx.lineTo(w, cy-RW/2);
    ctx.moveTo(0, cy+RW/2); ctx.lineTo(w, cy+RW/2);
  } else {
    ctx.moveTo(cx-RW/2, 0); ctx.lineTo(cx-RW/2, h);
    ctx.moveTo(cx+RW/2, 0); ctx.lineTo(cx+RW/2, h);
  }
  ctx.stroke();

  // Crosswalk stripes + stop lines at center of canvas
  const isEWGreen  = crossingPhase === 'ew-green';
  const isEWYellow = crossingPhase === 'ew-yellow';
  const isNSGreen  = crossingPhase === 'ns-green';
  const isNSYellow = crossingPhase === 'ns-yellow';
  const isPedWalk  = crossingPhase === 'pedestrian-walk';
  const isPedWarn  = crossingPhase === 'pedestrian-warn';
  const isGreen    = isH ? isEWGreen  : isNSGreen;
  const isYellow   = isH ? isEWYellow : isNSYellow;
  const isRed      = !isGreen && !isYellow;

  const CROSS_GAP = 4, SW = 6, SG = 5, nStripes = 5;
  const CROSS_W = nStripes*(SW+SG) - SG;
  const STOP_GAP = 8;
  const SLO = CROSS_GAP + CROSS_W + STOP_GAP;

  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  if (isH) {
    // Stripes across the road at cx
    for (let s = 0; s < nStripes; s++) {
      const so = CROSS_GAP + s*(SW+SG);
      ctx.fillRect(cx - so - SW, cy-RW/2, SW, RW);
      ctx.fillRect(cx + so,      cy-RW/2, SW, RW);
    }
    // Stop lines
    ctx.strokeStyle = 'rgba(255,255,255,0.55)'; ctx.lineWidth = 2.5; ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(cx - SLO, cy-RW/2); ctx.lineTo(cx - SLO, cy);       // eastbound
    ctx.moveTo(cx + SLO, cy);       ctx.lineTo(cx + SLO, cy+RW/2); // westbound
    ctx.stroke();
  } else {
    for (let s = 0; s < nStripes; s++) {
      const so = CROSS_GAP + s*(SW+SG);
      ctx.fillRect(cx-RW/2, cy - so - SW, RW, SW);
      ctx.fillRect(cx-RW/2, cy + so,      RW, SW);
    }
    ctx.strokeStyle = 'rgba(255,255,255,0.55)'; ctx.lineWidth = 2.5; ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(cx-RW/2, cy - SLO); ctx.lineTo(cx, cy - SLO);       // southbound
    ctx.moveTo(cx,      cy + SLO); ctx.lineTo(cx+RW/2, cy + SLO);  // northbound
    ctx.stroke();
  }

  // Traffic light pole
  const tlx = isH ? cx - 20 : cx + RW/2 + 14;
  const tly = isH ? cy - RW/2 - 14 : cy - 20;
  drawTrafficLightPole(ctx, tlx, tly, isH ? 'ew' : 'ns');

  // Pedestrian walk overlay (simple highlight)
  if (isPedWalk || isPedWarn) {
    const alpha = isPedWarn ? 0.3 + 0.2*Math.sin(Date.now()/200) : 0.18;
    ctx.fillStyle = `rgba(34,197,94,${alpha})`;
    if (isH) {
      ctx.fillRect(cx - CROSS_W/2 - CROSS_GAP, cy-RW/2, CROSS_W + CROSS_GAP*2, RW);
    } else {
      ctx.fillRect(cx-RW/2, cy - CROSS_W/2 - CROSS_GAP, RW, CROSS_W + CROSS_GAP*2);
    }
  }
}

// â”€â”€ SIDE-ON STREET VIEW â”€â”€
function drawRoadSideOn() {
  const { w, h, cx, cy } = getSimDimensions();
  const ctx = simCtx;

  // Sky / building background
  ctx.fillStyle = '#0e1118';
  ctx.fillRect(0, 0, w, h);

  // Buildings in background
  const buildings = [
    {x:20,  bw:80,  bh:120, c:'#131820'},
    {x:130, bw:60,  bh:90,  c:'#12161e'},
    {x:220, bw:100, bh:150, c:'#141922'},
    {x:360, bw:70,  bh:110, c:'#111620'},
    {x:460, bw:90,  bh:140, c:'#131820'},
    {x:580, bw:60,  bh:100, c:'#121620'},
    {x:660, bw:110, bh:160, c:'#141a24'},
    {x:800, bw:80,  bh:130, c:'#121620'},
  ];
  const groundY = h * 0.62; // road surface y
  buildings.forEach(b => {
    ctx.fillStyle = b.c;
    ctx.fillRect(b.x, groundY - b.bh, b.bw, b.bh);
    // Windows
    ctx.fillStyle = 'rgba(255,240,180,0.07)';
    for (let wy = groundY - b.bh + 12; wy < groundY - 16; wy += 22) {
      for (let wx = b.x + 8; wx < b.x + b.bw - 12; wx += 18) {
        ctx.fillRect(wx, wy, 10, 14);
      }
    }
    // lit windows
    ctx.fillStyle = 'rgba(255,240,100,0.25)';
    for (let wy = groundY - b.bh + 12; wy < groundY - 16; wy += 22) {
      for (let wx = b.x + 8; wx < b.x + b.bw - 12; wx += 18) {
        if ((wx + wy) % 44 < 18) ctx.fillRect(wx, wy, 10, 14);
      }
    }
  });

  // Road surface (2 lanes)
  const roadTop = groundY;
  const laneH   = 46;
  const roadH   = laneH * 2;
  ctx.fillStyle = '#22263a';
  ctx.fillRect(0, roadTop, w, roadH);

  // Pavement / kerb
  ctx.fillStyle = '#1a1d2a';
  ctx.fillRect(0, roadTop + roadH, w, h - roadTop - roadH);
  ctx.fillStyle = '#2a2e40';
  ctx.fillRect(0, roadTop + roadH, w, 8); // kerb highlight

  // Lane divider (dashed)
  ctx.strokeStyle = 'rgba(255,210,40,0.5)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([24, 18]);
  ctx.beginPath();
  ctx.moveTo(0, roadTop + laneH); ctx.lineTo(w, roadTop + laneH);
  ctx.stroke();
  ctx.setLineDash([]);

  // Road edge lines
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, roadTop); ctx.lineTo(w, roadTop);
  ctx.moveTo(0, roadTop + roadH); ctx.lineTo(w, roadTop + roadH);
  ctx.stroke();

  // Crosswalk stripes at cx â€” wider crosswalk, smaller wait zones on sides
  const isGreen  = crossingPhase === 'ew-green';
  const isYellow = crossingPhase === 'ew-yellow';
  const isPedWalk = crossingPhase === 'pedestrian-walk';
  const isPedWarn = crossingPhase === 'pedestrian-warn';

  const CROSS_GAP = 3, SW = 10, SG = 6, nStripes = 7;  // wider stripes, more of them
  const CROSS_W = nStripes*(SW+SG) - SG;  // ~106px vs original ~57px
  const SLO = CROSS_GAP + CROSS_W + 6;

  ctx.fillStyle = 'rgba(255,255,255,0.22)';
  for (let s = 0; s < nStripes; s++) {
    const so = CROSS_GAP + s*(SW+SG);
    ctx.fillRect(cx - so - SW, roadTop, SW, roadH);
    ctx.fillRect(cx + so,      roadTop, SW, roadH);
  }

  // Stop lines
  ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 2.5; ctx.setLineDash([]);
  ctx.beginPath();
  ctx.moveTo(cx - SLO, roadTop);       ctx.lineTo(cx - SLO, roadTop + laneH);   // eastbound
  ctx.moveTo(cx + SLO, roadTop + laneH); ctx.lineTo(cx + SLO, roadTop + roadH); // westbound
  ctx.stroke();

  // Pedestrian walk highlight
  if (isPedWalk || isPedWarn) {
    const alpha = isPedWarn ? 0.3 + 0.2*Math.sin(Date.now()/200) : 0.2;
    ctx.fillStyle = `rgba(34,197,94,${alpha})`;
    ctx.fillRect(cx - CROSS_W/2 - CROSS_GAP, roadTop, CROSS_W + CROSS_GAP*2, roadH);

    // Pedestrian figure on kerb
    const t = Date.now();
    const bob = Math.sin(t/200) * 2;
    const px = cx + 30, py = roadTop + roadH + 20;
    ctx.fillStyle = isPedWarn ? '#f59e0b' : '#22c55e';
    ctx.beginPath(); ctx.arc(px, py + bob - 8, 5, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = isPedWarn ? '#f59e0b' : '#22c55e';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(px, py + bob - 3); ctx.lineTo(px, py + bob + 8);
    const la = Math.sin(t/150) * 0.4;
    ctx.moveTo(px, py + bob - 2); ctx.lineTo(px - 5, py + bob + 4);
    ctx.moveTo(px, py + bob - 2); ctx.lineTo(px + 5, py + bob + 4);
    ctx.moveTo(px, py + bob + 8); ctx.lineTo(px - 4*Math.sin(la+0.3), py + bob + 16);
    ctx.moveTo(px, py + bob + 8); ctx.lineTo(px + 4*Math.sin(la-0.3), py + bob + 16);
    ctx.stroke();
  }

  // Traffic light pole (side of road)
  const tlx = cx - 30, tly = roadTop - 4;
  drawTrafficLightPoleSide(ctx, tlx, tly, isGreen, isYellow);
}

function drawTrafficLightPoleSide(ctx, x, y, isGreen, isYellow) {
  const isRed = !isGreen && !isYellow;
  // Pole
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y - 50); ctx.stroke();
  // Arm
  ctx.beginPath(); ctx.moveTo(x, y - 50); ctx.lineTo(x + 20, y - 50); ctx.stroke();
  // Housing
  ctx.fillStyle = '#111'; ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.roundRect(x + 13, y - 66, 14, 26, 3); ctx.fill(); ctx.stroke();
  // Bulbs
  const bulbs = [
    { c: isRed    ? '#ef4444' : 'rgba(239,68,68,0.12)',   glow: isRed    ? '#ef4444' : null, oy: -62 },
    { c: isYellow ? '#f59e0b' : 'rgba(245,158,11,0.12)',  glow: isYellow ? '#f59e0b' : null, oy: -54 },
    { c: isGreen  ? '#22c55e' : 'rgba(34,197,94,0.12)',   glow: isGreen  ? '#22c55e' : null, oy: -46 },
  ];
  bulbs.forEach(b => {
    if (b.glow) { ctx.shadowColor = b.glow; ctx.shadowBlur = 8; }
    ctx.fillStyle = b.c;
    ctx.beginPath(); ctx.arc(x + 20, y + b.oy, 4, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
  });
}

function drawCar(car) {
  const ctx = simCtx;
  // For horizontal cars (east/west): car is wider than tall
  // For vertical cars (north/south): car is taller than wide
  const isH = car.dir === 'east' || car.dir === 'west';
  // Car body: 36px long, 20px wide â€” fits in 45px lane with margin
  const bodyL = 36; // along direction of travel
  const bodyW = 20; // perpendicular to travel
  const bw = isH ? bodyL : bodyW;  // canvas x-dimension of body
  const bh = isH ? bodyW : bodyL;  // canvas y-dimension of body

  ctx.save();
  ctx.translate(Math.round(car.x), Math.round(car.y));

  // Drop shadow
  ctx.shadowColor = 'rgba(0,0,0,0.6)';
  ctx.shadowBlur = 6;
  ctx.shadowOffsetX = 1;
  ctx.shadowOffsetY = 2;

  // Car body (centered on 0,0)
  ctx.fillStyle = car.color;
  ctx.beginPath();
  ctx.roundRect(-bw/2, -bh/2, bw, bh, 3);
  ctx.fill();
  ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;

  // Roof / cab tint (darker center rectangle)
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  if (isH) {
    ctx.fillRect(-bw/2 + 6, -bh/2 + 3, bw - 12, bh - 6);
  } else {
    ctx.fillRect(-bw/2 + 3, -bh/2 + 6, bw - 6, bh - 12);
  }

  // Windshield highlight
  ctx.fillStyle = 'rgba(160,220,255,0.25)';
  if (car.dir === 'east')  ctx.fillRect( bw/2-10, -bh/2+3, 7, bh-6);
  if (car.dir === 'west')  ctx.fillRect(-bw/2+3,  -bh/2+3, 7, bh-6);
  if (car.dir === 'south') ctx.fillRect(-bw/2+3,   bh/2-10, bw-6, 7);
  if (car.dir === 'north') ctx.fillRect(-bw/2+3,  -bh/2+3, bw-6, 7);

  // Lights
  const isStopped = car.state === 'stopped' || car.state === 'slowing';
  const brakeOn = isStopped ? '#ef4444' : 'rgba(180,20,20,0.5)';
  const headOn  = '#fffce0';

  ctx.shadowBlur = 5;
  if (car.dir === 'east') {
    ctx.fillStyle = headOn;  ctx.shadowColor = headOn;
    ctx.fillRect( bw/2-2, -bh/2+2, 2, 4);
    ctx.fillRect( bw/2-2,  bh/2-6, 2, 4);
    ctx.fillStyle = brakeOn; ctx.shadowColor = '#ef4444';
    ctx.shadowBlur = isStopped ? 8 : 2;
    ctx.fillRect(-bw/2,   -bh/2+2, 2, 4);
    ctx.fillRect(-bw/2,    bh/2-6, 2, 4);
  } else if (car.dir === 'west') {
    ctx.fillStyle = headOn;  ctx.shadowColor = headOn;
    ctx.fillRect(-bw/2,   -bh/2+2, 2, 4);
    ctx.fillRect(-bw/2,    bh/2-6, 2, 4);
    ctx.fillStyle = brakeOn; ctx.shadowColor = '#ef4444';
    ctx.shadowBlur = isStopped ? 8 : 2;
    ctx.fillRect( bw/2-2, -bh/2+2, 2, 4);
    ctx.fillRect( bw/2-2,  bh/2-6, 2, 4);
  } else if (car.dir === 'south') {
    ctx.fillStyle = headOn;  ctx.shadowColor = headOn;
    ctx.fillRect(-bw/2+2,  bh/2-2, 4, 2);
    ctx.fillRect( bw/2-6,  bh/2-2, 4, 2);
    ctx.fillStyle = brakeOn; ctx.shadowColor = '#ef4444';
    ctx.shadowBlur = isStopped ? 8 : 2;
    ctx.fillRect(-bw/2+2, -bh/2,   4, 2);
    ctx.fillRect( bw/2-6, -bh/2,   4, 2);
  } else { // north
    ctx.fillStyle = headOn;  ctx.shadowColor = headOn;
    ctx.fillRect(-bw/2+2, -bh/2,   4, 2);
    ctx.fillRect( bw/2-6, -bh/2,   4, 2);
    ctx.fillStyle = brakeOn; ctx.shadowColor = '#ef4444';
    ctx.shadowBlur = isStopped ? 8 : 2;
    ctx.fillRect(-bw/2+2,  bh/2-2, 4, 2);
    ctx.fillRect( bw/2-6,  bh/2-2, 4, 2);
  }

  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawPedestrianOverlay() {
  const { cx, cy } = getSimDimensions();
  const ctx = simCtx;
  const isWalking = crossingPhase === 'pedestrian-walk';
  const isWarning = crossingPhase === 'pedestrian-warn';

  if (isWalking || isWarning) {
    const alpha = isWarning ? 0.3 + 0.2*Math.sin(Date.now()/200) : 0.18;
    ctx.fillStyle = `rgba(34,197,94,${alpha})`;
    const CROSS_W = 50; // 5 stripes Ã— 11px - 5 = 50px
    const CROSS_GAP = 4;
    // Crosswalk highlight â€” sits between intersection edge and stop line
    ctx.fillRect(cx-ROAD_W/2, cy-ROAD_W/2 - CROSS_GAP - CROSS_W, ROAD_W, CROSS_W + CROSS_GAP);
    ctx.fillRect(cx-ROAD_W/2, cy+ROAD_W/2 + CROSS_GAP,            ROAD_W, CROSS_W + CROSS_GAP);

    // Animated pedestrian figures
    const t = Date.now();
    const figures = [
      { x: cx - 20, y: cy - sl - 12, phase: 0 },
      { x: cx + 10, y: cy + sl + 12, phase: Math.PI },
    ];
    figures.forEach(f => {
      const bob = Math.sin(t/200 + f.phase) * 2;
      ctx.fillStyle = isWarning ? '#f59e0b' : '#22c55e';
      ctx.beginPath();
      ctx.arc(f.x, f.y + bob - 6, 4, 0, Math.PI*2); // head
      ctx.fill();
      ctx.strokeStyle = isWarning ? '#f59e0b' : '#22c55e';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(f.x, f.y + bob - 2);
      ctx.lineTo(f.x, f.y + bob + 6); // body
      ctx.moveTo(f.x, f.y + bob + 1);
      ctx.lineTo(f.x - 4, f.y + bob + 4); // arm L
      ctx.moveTo(f.x, f.y + bob + 1);
      ctx.lineTo(f.x + 4, f.y + bob + 4); // arm R
      const legAngle = Math.sin(t/150 + f.phase) * 0.4;
      ctx.moveTo(f.x, f.y + bob + 6);
      ctx.lineTo(f.x - 4*Math.sin(legAngle+0.3), f.y + bob + 12);
      ctx.moveTo(f.x, f.y + bob + 6);
      ctx.lineTo(f.x + 4*Math.sin(legAngle-0.3), f.y + bob + 12);
      ctx.stroke();
    });
  }
}

function updateSimSidebar() {
  const vGreen  = crossingPhase === 'ew-green' || crossingPhase === 'ns-green';
  const vYellow = crossingPhase === 'ew-yellow' || crossingPhase === 'ns-yellow';
  const vRed    = !vGreen && !vYellow;
  const isWalk  = crossingPhase === 'pedestrian-walk';
  const isWarn  = crossingPhase === 'pedestrian-warn';

  // Sim sidebar bulbs â€” vehicle lights (same rule: green=vehicle moving, red=ped walking)
  ['sbulb-red','sbulb-red2'].forEach(id => {
    const el = document.getElementById(id); if (el) el.className = 'sim-bulb red' + (vRed ? ' on' : '');
  });
  ['sbulb-yellow','sbulb-yellow2'].forEach(id => {
    const el = document.getElementById(id); if (el) el.className = 'sim-bulb yellow' + (vYellow ? ' on' : '');
  });
  ['sbulb-green','sbulb-green2'].forEach(id => {
    const el = document.getElementById(id); if (el) el.className = 'sim-bulb green' + (vGreen ? ' on' : '');
  });

  // Pedestrian icon
  const pedIcon = document.getElementById('sim-ped-icon');
  if (pedIcon) {
    if (isWalk)     { pedIcon.textContent = 'ğŸš¶'; pedIcon.className = 'sim-ped-icon walk'; }
    else if (isWarn){ pedIcon.textContent = 'ğŸš·'; pedIcon.className = 'sim-ped-icon'; }
    else            { pedIcon.textContent = 'ğŸ›‘'; pedIcon.className = 'sim-ped-icon'; }
  }

  const cd = document.getElementById('sim-countdown');
  if (cd) cd.textContent = phaseTimer;

  const tag = document.getElementById('sim-phase-tag');
  if (tag) {
    const phases = {
      'ew-green':        ['EW Green', 'phase-tag-go'],
      'ew-yellow':       ['EW Yellow', 'phase-tag-warn'],
      'ns-green':        ['NS Green', 'phase-tag-go'],
      'ns-yellow':       ['NS Yellow', 'phase-tag-warn'],
      'pedestrian-walk': ['Walk Signal',   'phase-tag-stop'],
      'pedestrian-warn': ['Warning',       'phase-tag-warn'],
    };
    const [label, cls] = phases[crossingPhase] || ['â€”', 'phase-tag-stop'];
    tag.textContent = label;
    tag.className = 'sim-phase-tag ' + cls;
  }
}

function addSimEvent(msg, type='') {
  const list = document.getElementById('sim-event-list');
  const now = new Date();
  const t = [now.getHours(),now.getMinutes(),now.getSeconds()].map(v=>String(v).padStart(2,'0')).join(':');

  // Remove placeholder
  if (list.children.length === 1 && list.children[0].tagName === 'DIV' && !list.children[0].className.includes('sim-evt')) {
    list.innerHTML='';
  }

  const item = document.createElement('div');
  item.className = 'sim-evt ' + type;
  item.innerHTML = `<span class="sim-evt-time">${t}</span><span>${msg}</span>`;
  list.insertBefore(item, list.firstChild);
  while (list.children.length > 40) list.removeChild(list.lastChild);
}

// Hook into phase changes for sim events
const _origOnPhaseStart = onPhaseStart;
// Override with extended version that also fires sim events
function onPhaseStartFull(phase) {
  _origOnPhaseStart(phase);
  if (page === 'sim' || true) {
    switch(phase) {
      case 'ew-green':
        addSimEvent('ğŸŸ¢ East-West green â€” EW cars flowing', 'go-evt');
        break;
      case 'ns-green':
        addSimEvent('ğŸŸ¢ North-South green â€” NS cars flowing', 'go-evt');
        break;
      case 'ew-yellow':
      case 'ns-yellow':
        addSimEvent('ğŸŸ¡ Yellow â€” vehicles slowing', 'warn-evt');
        break;
      case 'pedestrian-walk':
        const t = getCrossingTime();
        addSimEvent(`ğŸš¶ Pedestrian walk signal â€” ${t}s${mobilityDetected?' (extended)':''}`, 'highlight');
        break;
      case 'pedestrian-warn':
        addSimEvent('âš ï¸ Walk signal ending', 'warn-evt');
        break;
    }
  }
}

// Patch onPhaseStart
window._simPatchedPhaseStart = true;

function simLoop(ts) {
  if (!simRunning) return;

  const rawDt = (ts - simLastTime) / 1000;
  simLastTime = ts;
  const dt = Math.min(rawDt, 0.05) * simSpeed;

  // Resize canvas to element size
  const rect = simCanvas.getBoundingClientRect();
  if (simCanvas.width !== rect.width || simCanvas.height !== rect.height) {
    simCanvas.width = Math.round(rect.width);
    simCanvas.height = Math.round(rect.height);
  }

  // Draw road
  if (simViewMode === 'sideon') {
    drawRoadSideOn();
  } else if (simViewMode === 'horizontal') {
    drawRoadSingle('horizontal');
  } else if (simViewMode === 'vertical') {
    drawRoadSingle('vertical');
  } else {
    drawRoad();
  }

  // Auto spawn
  autoSpawn();

  // Update and draw cars (back to front by y for NS, just loop for EW)
  updateCars(dt);

  // Sort cars for depth (south-facing cars drawn last = on top)
  const sorted = [...simCars].sort((a,b) => {
    const aIsV = a.dir==='north'||a.dir==='south';
    const bIsV = b.dir==='north'||b.dir==='south';
    if (aIsV && !bIsV) return 1;
    if (!aIsV && bIsV) return -1;
    return a.y - b.y;
  });
  sorted.forEach(c => drawCar(c));

  // Pedestrian overlay
  drawPedestrianOverlay();

  // Sidebar sync
  updateSimSidebar();

  simAnimId = requestAnimationFrame(simLoop);
}

function toggleSim() {
  if (simRunning) {
    simRunning = false;
    cancelAnimationFrame(simAnimId);
    document.getElementById('sim-toggle-btn').textContent = 'â–¶ Start Simulation';
    addSimEvent('â¸ Simulation paused', '');
  } else {
    simRunning = true;
    simLastTime = performance.now();
    document.getElementById('sim-toggle-btn').textContent = 'â¸ Pause';
    addSimEvent('â–¶ Simulation started', 'highlight');
    simAnimId = requestAnimationFrame(simLoop);
    // Seed a few staggered cars
    ['east','west','north','south'].forEach((d,i) => {
      setTimeout(() => spawnCar(d, 0), i * 400);
    });
  }
}

// Auto-start sim when switching to sim page â€” handled via nav onclick in HTML

// Also fire sim events from original phase system â€” hook via simPhaseHook
function simPhaseHook(phase) {
  switch(phase) {
    case 'ew-green':
      setTimeout(()=>addSimEvent('ğŸŸ¢ East-West green â€” EW cars flowing','go-evt'),10); break;
    case 'ns-green':
      setTimeout(()=>addSimEvent('ğŸŸ¢ North-South green â€” NS cars flowing','go-evt'),10); break;
    case 'ew-yellow':
    case 'ns-yellow':
      setTimeout(()=>addSimEvent('ğŸŸ¡ Yellow â€” vehicles decelerating','warn-evt'),10); break;
    case 'pedestrian-walk':
      const ct = getCrossingTime();
      setTimeout(()=>addSimEvent(`ğŸš¶ Pedestrian walk signal â€” ${ct}s${mobilityDetected?' (+mobility ext)':''}`,'highlight'),10); break;
    case 'pedestrian-warn':
      setTimeout(()=>addSimEvent('âš ï¸ Signal ending soon','warn-evt'),10); break;
  }
}

seedLog();
loadModel();
// Populate camera list on load, and refresh if devices are plugged/unplugged
enumerateCameras();
navigator.mediaDevices.addEventListener('devicechange', () => {
  if (!running) enumerateCameras();
});


</script>
</body>
</html>
